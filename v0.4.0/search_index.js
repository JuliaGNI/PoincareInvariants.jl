var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"guides/pendulum/#Pendulum","page":"Pendulum","title":"Pendulum","text":"","category":"section"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"In this tutorial we integrate the equations of motion for a pendulum and compute the first and second Poincaré integral invariants. First, we integrate the equations of motion then we can compute the invariants to check whether they are in fact conserved. The full script to generate the plots and do the computations shown here can be found at examples/pendulum.jl.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Let us begin. We will need to import PoincareInvariants.jl.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"using PoincareInvariants","category":"page"},{"location":"guides/pendulum/#Integration","page":"Pendulum","title":"Integration","text":"","category":"section"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"We'll quickly write our own integration code here for simplicity. This library can be used with DifferentialEquations.jl. For the purposes of this tutorial we pick a unit system, such that gravity, mass and length are equal to one. The equations of motion for the angle theta and angular momentum p for a simple pendulum are therefore given by","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"dottheta = p dotp = -sintheta","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"To integrate these equations of motion we will compare the backward Euler method, the symplectic Euler method and the Runge-Kutta method (RK4). The following shows the implementations for stepping forward by one time step for each method.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"pendulum((θ, p)) = (p, -sin(θ))\n\nstruct BackwardEuler end\nfunction timestep((θ, p), dt, ::BackwardEuler)\n    sinθ, cosθ = sincos(θ)\n    p = (p - dt * sinθ) / (1 + dt^2 * cosθ)\n    return θ + dt * p, p\nend\n\nstruct SymplecticEuler end\nfunction timestep((θ, p), dt, ::SymplecticEuler)\n    θ = θ + dt * p  # update position\n    p = p - dt * sin(θ)  # update momentum\n    return θ, p\nend\n\nstruct RK4 end\nfunction timestep((θ, p), dt, ::RK4)\n    k1 = pendulum((θ, p))\n    k2 = pendulum((θ, p) .+ 0.5 .* dt .* k1)\n    k3 = pendulum((θ, p) .+ 0.5 .* dt .* k2)\n    k4 = pendulum((θ, p) .+ dt .* k3)\n    return (θ, p) .+ (dt/6) .* (k1 .+ 2 .* k2 .+ 2 .* k3 .+ k4)\nend","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"We'll also need some code to step many times and save the result.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"\"\"\"\n    integrate((θ₀, p₀), dt, nsteps, nt, method)\n\nstart at `(θ₀, p₀)` and integrate the equations of motion using `method`.\nReturns the timeseries as a vector of tuples. `nt` points are saved,\n`nsteps` steps are taken from saved point to saved point and `dt` is the\nsize of each time step.\n\"\"\"\nfunction integrate((θ₀, p₀), dt, nsteps, nt, method)\n    out = Vector{Tuple{Float64, Float64}}(undef, nt)\n    (θ, p) = out[1] = (θ₀, p₀)\n    for i in 2:nt\n        for _ in 1:nsteps\n            (θ, p) = timestep((θ, p), dt, method)\n        end\n        out[i] = (θ, p)\n    end\n    return out\nend","category":"page"},{"location":"guides/pendulum/#Computing-the-Invariants","page":"Pendulum","title":"Computing the Invariants","text":"","category":"section"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"The first invariant is the integral","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"I_1 = int_gamma p(theta)  dtheta","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"which remains invariant as each point (theta(t) p(t)) on the curve gamma moves in phasespace according to the above equations of motion. The second invariant is the integral","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"I_2 = int_S dtheta  dp","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"which remains invariant as each point (theta(t) p(t)) on the surface S moves in phasespace according to the above equations of motion.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"However, our numerical integration methods only approximate the true dynamics. So we might ask whether the two invariants are preserved, even when integrated only approximately. To answer this question we compute the two integral invariants numerically. The general approach to computing the invariants goes as follows.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Approximate the intial curve or surface in phasespace with a finite number of points.\nCompute the initial curve or surface integral using the approximation given by the set of points.\nMove the set of points in phasespace by integrating the equations of motion for each.\nCompute the integral invariant again using the moved set of points to approximate the curve or surface.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"In code, we start by initialising the setup objects CanonicalFirstPI and CanonicalSecondPI to preallocate everything we'll need for further computation.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"pi1 = CanonicalFirstPI{Float64, 2}(500)\npi2 = CanonicalSecondPI{Float64, 2}(10_000)","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Float64 refers to the numeric type to use for calculations. For example, you could switch to DoubleFloats.jl for improved accuracy. The 2 refers to the dimension of phasespace. In our case, that's two, since the pendulum has two degrees of freedom, namely the angle and angular momentum. Finally, the numbers 1_000 and 10_000 refer to how many points to use to approximate the curve and surface in phasespace. The exact number of points actually used depends on the implementation used and may be inspected with getpointnum","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"@assert 500 ≤ getpointnum(pi1) ≤ 750\n@assert 10_000 ≤ getpointnum(pi2) ≤ 15_000","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Next, we'll need to initialise the curve and surface. For the first invariant, we use a unit circle stretched by a factor of three as our curve. The corresponding invariant is 3pi. For the second invariant, we use a four by four square centered at the origin. The corresponding invariant is 16.  In code, this looks like","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"I1 = 3π\npnts1 = getpoints(pi1) do ϕ\n    sinpi(2ϕ), 3 * cospi(2ϕ)\nend\n\nI2 = 16\npnts2 = getpoints(pi2) do x, y\n    4 .* (x, y) .- 2\nend","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"getpoints takes a parameterisation as its first argument and the setup object as its second argument. It returns a matrix, where each row is a point. The parameterisation must accept a value in the domain and maps it to a point in phase space, representing a point on the curve or surface to be integrated over. For the first invariant the domain is just 01 and the parameterisation must be periodic. For the second invariant the domain is 01^2, so the corresponding parameterisation must accept two inputs. The exact points in the domain at which the parameterisations are evaluated changes depending on the underlying implementation. The points used by the current implementation may be inspected using getpoints without a function argument.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"getpoints(pi1)\ngetpoints(pi2)","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Below is a plot of the initial points in phasespace.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"(Image: )","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Having initialised our initial curve and surface, we may compute the invariant as follows.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"@assert isapprox(compute!(pi1, pnts1), I1; atol=10eps())\n@assert isapprox(compute!(pi2, pnts2), I2; atol=10eps())","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Now we'll want to integrate the equations of motion. To do this, let's introduce a quick helper function to integrate all points or rows.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"integrate(mat::AbstractMatrix, dt, nsteps, nt, method) = map(eachrow(mat)) do pnt\n    integrate((pnt[1], pnt[2]), dt, nsteps, nt, method)\nend","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"As it turns out, compute! will work out of the box with a vector of time series like this. So we can just do","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"series1 = integrate(pnts1, 0.05, 15, 5, SymplecticEuler())\n@assert all(compute!(pi1, series1)) do I\n    abs(I - I1) < 10^(-14)\nend\n\nseries2 = integrate(pnts2, 0.05, 15, 5, SymplecticEuler())\n@assert all(compute!(pi2, series2)) do I\n    abs(I - I2) < 10^(-13)\nend","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"When compute! is given time series like this it will calculate the invariant for each time and return a Vector of the invariant values. Below is a plot of the points in phasespace and invariants over time. The left column corresponds to the first invariant and the right corresponds to the second. The top two plots show the increasingly distorted curve and surface over time, while the bottom two plots show the error in the invariant over time for different integration algorithms.","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"(Image: )","category":"page"},{"location":"guides/pendulum/","page":"Pendulum","title":"Pendulum","text":"Given the data shown above, we can confirm that SymplecticEuler is in fact symplectic and preserves the two invariants very well, while the other two methods are not symplectic and hence do not conserve the associated invariants. These data are all the more impressive when you consider the significant distortion of the initial curve and surface and that SymplecticEuler is a first order method whereas RK4 is a fourth order method.","category":"page"},{"location":"guides/plans/#Using-Different-Integral-Implementations","page":"Plans","title":"Using Different Integral Implementations","text":"","category":"section"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"There are a number of different implementations to choose from to calculate the invariants. For the first invariant, the choices are","category":"page"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"FirstPI{T, D}(θ, N, FirstFinDiffPlan)\nFirstPI{T, D}(θ, N, FirstFourierPlan)","category":"page"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"where FirstFourierPlan is the default if no plan type is given. FirstFinDiffPlan uses a finite difference approximation of the derivatives and calculates the final integral via the trapezoid rule. FirstFourierPlan transforms to frequency space, where the derivative is trivial, and computes the final integral in frequency space.","category":"page"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"For the second invariant, there are two choices:","category":"page"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"SecondPI{T, D}(θ, N, SecondChebyshevPlan)\nSecondPI{T, D}(θ, (Nx, Ny), SecondFinDiffPlan)","category":"page"},{"location":"guides/plans/","page":"Plans","title":"Plans","text":"where SecondChebyshevPlan is the default. SecondFinDiffPlan uses finite differences to calculate the derivatives of the parameterisation and calculates the final integral via Simpson's rule. If the parameterisation is a second order polynomial, this method is exact. Note, that the finite difference implementation can use an arbitrary grid, which maybe specified with a tuple (Nx, Ny). Alternatively, giving just a number N will result in using a square grid of points. SecondChebyshevPlan uses the Padua transform, as implemented in ChebyshevTransforms.jl to transform to a Chebyshev polynomial basis. In this basis, derivatives are calculated and then transformed back again. After evaluating the differential form at all points and contracting with the derivatives, another Padua transform is used to evaluate the final integral.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"DocTestSetup  = quote\n    using PoincareInvariants\nend","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"PoincareInvariants","category":"page"},{"location":"reference/#PoincareInvariants","page":"Reference","title":"PoincareInvariants","text":"PoincareInvariants\n\nA Julia library for the computation of Poincaré integral invariants.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Fundamentals","page":"Reference","title":"Fundamentals","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"compute!\nFirstPoincareInvariant\nFirstPoincareInvariant{T, D}(θ::θT, N::Integer, plan::P) where {T, D, θT, P}\nFirstPoincareInvariant{T, D}(θ::θT, N::Integer, P::Type=DEFAULT_FIRST_PLAN) where {T, D, θT}\nFirstPoincareInvariant{T, D, typeof(canonical_one_form)}(N::Integer, P=DEFAULT_FIRST_PLAN) where {T, D}\nSecondPoincareInvariant\nSecondPoincareInvariant{T, D}(ω::ωT, N, plan::P) where {T, D, ωT, P}\nSecondPoincareInvariant{T, D}(ω, N, P::Type=DEFAULT_SECOND_PLAN) where {T, D}\nSecondPoincareInvariant{T, D, CanonicalSymplecticMatrix{T}}(N, P::Type=DEFAULT_SECOND_PLAN) where {T, D}","category":"page"},{"location":"reference/#PoincareInvariants.compute!","page":"Reference","title":"PoincareInvariants.compute!","text":"compute!(pinv::AbstractPoincareInvariant, points::AbstractMatrix, t::Real=NaN, p=nothing)\n\ncomputes a Poincaré invariant using setup object pinv, where points represents the image of the curve or surface parameterisation evaluated on some set of points, e.g. a grid.\n\nt is the time at which the invariant is evaluated p are any user supplied optional arguments. Both t and p are passed directly to the differential form.\n\nPlan implementations should define a method compute!(pinv, t::Real, p), which acts on the internal points storage pinv.points.\n\n\n\n\n\ncompute!(pinv::AbstractPoincareInvariant, points::AbstractVector{<:AbstractVector},\n    times::Union{AbstractVector{<:Real}, Real}=NaN, p=nothing)\n\ncomputes a Poincaré invariant, using the setup object pinv, at each time for a set of trajectories given by points.\n\npoints represents an AbstractVector of trajectories. Each element of points is a trajectory, which is itself an AbstractVector of some kind of iterable or vector. times is either a constant, like NaN, or a vector of the times at which the trajectories have been evaluated, i.e. the i-th phase space position in each trajectory was evaluated at time times[i]. p is an arbitrary optional parameter which is passed to the differential form, like the the time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.FirstPoincareInvariant","page":"Reference","title":"PoincareInvariants.FirstPoincareInvariant","text":"FirstPoincareInvariant{T, D, θT, P} <: AbstractPoincareInvariant{T, D}\nFirstPI{T, D, θT, P} <: AbstractPoincareInvariant{T, D}\n\nsetup object to compute the first invariant.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PoincareInvariants.FirstPoincareInvariant-Union{Tuple{P}, Tuple{θT}, Tuple{D}, Tuple{T}, Tuple{θT, Integer, P}} where {T, D, θT, P}","page":"Reference","title":"PoincareInvariants.FirstPoincareInvariant","text":"FirstPoincareInvariant{T, D}(θ::θT, N::Integer, plan::P)\n\nconstructs a FirstPoincareInvariant setup object to calculate integral invariants, given a numeric type T, a phase space dimension D, a differential form θ, a number of points N and a plan. Note that the number of points may not be exactly N. The true number used depends on the implementation and is guaranteed to be no smaller than N and not too much larger.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PoincareInvariants.FirstPoincareInvariant-Union{Tuple{θT}, Tuple{D}, Tuple{T}, Tuple{θT, Integer}, Tuple{θT, Integer, Type}} where {T, D, θT}","page":"Reference","title":"PoincareInvariants.FirstPoincareInvariant","text":"FirstPoincareInvariant{T, D}(θ::θT, N::Integer, P::Type=DEFAULT_FIRST_PLAN)\n\nconstructs a FirstPoincareInvariant setup object to calculate integral invariants, given a numeric type T, a phase space dimension D, a differential form θ, a number of points N and a plan type P, to be initialised and used for future computation.\n\nThe plan type defaults to DEFAULT_FIRST_PLAN, which is currently set to FirstFourierPlan.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PoincareInvariants.FirstPoincareInvariant-Union{Tuple{Integer}, Tuple{D}, Tuple{T}, Tuple{Integer, Any}} where {T, D}","page":"Reference","title":"PoincareInvariants.FirstPoincareInvariant","text":"FirstPoincareInvariant{T, D, typeof(canonical_one_form)}(N::Integer, P=DEFAULT_FIRST_PLAN)\nCanonicalFirstPI{T, D}(N::Integer, P=DEFAULT_FIRST_PLAN)\n\ncreates a setup object to compute the first integral invariant using the canonical one form in phase space of dimension D with numeric type T, N points and plan type P.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PoincareInvariants.SecondPoincareInvariant","page":"Reference","title":"PoincareInvariants.SecondPoincareInvariant","text":"SecondPoincareInvariant{T, D, ωT, PS, P} <: AbstractPoincareInvariant{T, D}\nSecondPI{T, D, ωT, PS, P} <: AbstractPoincareInvariant{T, D}\n\nsetup object used to compute the second invariant.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PoincareInvariants.SecondPoincareInvariant-Union{Tuple{P}, Tuple{ωT}, Tuple{D}, Tuple{T}, Tuple{ωT, Any, P}} where {T, D, ωT, P}","page":"Reference","title":"PoincareInvariants.SecondPoincareInvariant","text":"SecondPoincareInvariant{T, D}(ω, N, plan::P)\n\nconstructs a SecondPoincareInvariant setup object to calculate integral invariants, given a numeric type T, a phase space dimension D, a differential form ω, a point specification N, usually a number of points, and a plan.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PoincareInvariants.SecondPoincareInvariant-Union{Tuple{D}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type}} where {T, D}","page":"Reference","title":"PoincareInvariants.SecondPoincareInvariant","text":"SecondPoincareInvariant{T, D}(ω, N, P::Type=DEFAULT_SECOND_PLAN)\n\nconstructs a SecondPoincareInvariant setup object to calculate integral invariants, given a numeric type T, a phase space dimension D, a differential form ω, a point specification N and a plan type P, to be initialised and used for future computation.\n\nThe plan type defaults to DEFAULT_SECOND_PLAN, which is currently set to SecondChebyshevPlan. Note that the number of points may not be exactly N. The true number used depends on the implementation and is guaranteed to be no smaller than N and not too much larger. For the SecondFinDiffPlan, the grid of points may also be specified as a tuple (Nx, Ny), if non-square grids are sought.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PoincareInvariants.SecondPoincareInvariant-Union{Tuple{Any}, Tuple{D}, Tuple{T}, Tuple{Any, Type}} where {T, D}","page":"Reference","title":"PoincareInvariants.SecondPoincareInvariant","text":"SecondPoincareInvariant{T, D, CanonicalSymplecticMatrix{T}}(N, P=DEFAULT_FIRST_PLAN)\nCanonicalSecondPI{T, D}(N, P=DEFAULT_FIRST_PLAN)\n\ncreates a setup object to compute the second integral invariant using the canonical two form in phase space of dimension D with numeric type T, point specification N and plan type P.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Interface","page":"Reference","title":"Interface","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AbstractPoincareInvariant\ngetpoints\ngetpointnum\ngetpointspec\ngetdim\ngetform\ngetplan","category":"page"},{"location":"reference/#PoincareInvariants.AbstractPoincareInvariant","page":"Reference","title":"PoincareInvariants.AbstractPoincareInvariant","text":"AbstractPoincareInvariant{T, D}\n\nrepresents a Poincare integral invariant in a phase space of dimension Dusing numeric typeT` for calculations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PoincareInvariants.getpoints","page":"Reference","title":"PoincareInvariants.getpoints","text":"getpoints(pinv::AbstractPoincareInvariant)\n\nreturns points on which to evaluate the phase space line or surface parameterisation so as to compute! pinv.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getpointnum","page":"Reference","title":"PoincareInvariants.getpointnum","text":"getpointnum(pinv::AbstractPoincareInvariant)\n\nreturns number of points to sample in phase space to compute! pinv.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getpointspec","page":"Reference","title":"PoincareInvariants.getpointspec","text":"getpointspec(pinv::AbstractPoincareInvariant)\n\nget point specification, which may, for example, be a tuple specifying a grid or a number giving the number of points used to sample in phase space.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getdim","page":"Reference","title":"PoincareInvariants.getdim","text":"getdim(pinv::AbstractPoincareInvariant)\n\nreturns dimension of phase space to compute! pinv in.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getform","page":"Reference","title":"PoincareInvariants.getform","text":"getform(pinv::AbstractPoincareInvariant)\n\nget invariant one- or two-form.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getplan","page":"Reference","title":"PoincareInvariants.getplan","text":"getplan(pinv::AbstractPoincareInvariant)\n\nreturns the plan that will be used to compute! pinv.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Canonical-Symplectic-Forms","page":"Reference","title":"Canonical Symplectic Forms","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CanonicalSymplecticMatrix","category":"page"},{"location":"reference/#PoincareInvariants.CanonicalSymplecticForms.CanonicalSymplecticMatrix","page":"Reference","title":"PoincareInvariants.CanonicalSymplecticForms.CanonicalSymplecticMatrix","text":"CanonicalSymplecticMatrix{T}(n::Integer)\n\nconstructs a canonical symplectic matrix of size (n, n) with eltype T. n must be even and positive. See the examples to see the form of the canonical symplectic matrix as defined here.\n\nExamples\n\njulia> CanonicalSymplecticMatrix(4)\n4×4 CanonicalSymplecticMatrix{Int64}:\n 0  0  -1   0\n 0  0   0  -1\n 1  0   0   0\n 0  1   0   0\n\njulia> CanonicalSymplecticMatrix{Int32}(6)\n6×6 CanonicalSymplecticMatrix{Int32}:\n 0  0  0  -1   0   0\n 0  0  0   0  -1   0\n 0  0  0   0   0  -1\n 1  0  0   0   0   0\n 0  1  0   0   0   0\n 0  0  1   0   0   0\n\n\n\n\n\n","category":"type"},{"location":"guides/charged_particle/#Charged-Particle","page":"Charged Particle","title":"Charged Particle","text":"","category":"section"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"In the second part of the tutorial we will treat a non-canonical system and show how to compute! Poincaré integral invariants for it. The system consists of a 2D charged particle subject to electromagnetic fields. The equations of motion are","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"dotx = v dotv = E(x) + v  B(x)","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"where x is the position vector, v is the velocity, E and B are the electric and magnetic field and the mass and charge of the particle is set to one. For our example we will use a constant magnetic field of strength 10 pointing in the z-direction and an electric field given by E(x y) = (-x -y^3).","category":"page"},{"location":"guides/charged_particle/#Integration","page":"Charged Particle","title":"Integration","text":"","category":"section"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"Again, we'll quickly implement our own integrators here, namely the Runge-Kutta method (RK4) and a second order symplectic splitting method for charged particles in electromagnetic fields.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"using PoincareInvariants\nusing StaticArrays\n\nE(x, y) = (-x, -y^3)\n\nA(x, y) = 5 .* (-y, x)\nB(x, y) = 10.0\nBx(x, y, Δx) = 10 * Δx  # integral in x direction from x to x + Δx\nBy(x, y, Δy) = 10 * Δy  # integral in y direction from y to y + Δy\n\nstruct Split2 end\n\nfunction ϕx((x, y, vx, vy), dt)\n    Δx = vx * dt\n    return (x + Δx, y, vx, vy - Bx(x, y, Δx))\nend\n\nfunction ϕy((x, y, vx, vy), dt)\n    Δy = vy * dt\n    return (x, y + Δy, vx + By(x, y, Δy), vy)\nend\n\nfunction ϕE((x, y, vx, vy), dt)\n    (Δvx, Δvy) = dt .* E(x, y)\n    return (x, y, vx + Δvx, vy + Δvy)\nend\n\nfunction timestep(z, dt, ::Split2)\n    hdt = 0.5 * dt\n    z = ϕx(z, hdt)\n    z = ϕy(z, hdt)\n    z = ϕE(z, dt)\n    z = ϕy(z, hdt)\n    z = ϕx(z, hdt)\n    return z\nend\n\nstruct RK4 end\n\nfunction zdot((x, y, vx, vy))\n    ex, ey = E(x, y); b = B(x, y)\n    (vx, vy, ex + b * vy, ey - b * vx)\nend\n\nfunction timestep(z, dt, ::RK4)\n    hdt = 0.5 .* dt\n    k1 = zdot(z)\n    k2 = zdot(z .+ hdt .* k1)\n    k3 = zdot(z .+ hdt .* k2)\n    k4 = zdot(z .+  dt .* k3)\n    return z .+ dt .* (k1 .+ 2 .* k2 .+ 2 .* k3 .+ k4) .* (1/6)\nend\n\n\"\"\"\n    integrate(z0, dt, nsteps, nt, method)\n\nstart at `z0` and integrate the equations of motion using `method`.\nReturns the timeseries as a vector of tuples. `nt` points are saved,\n`nsteps` steps are taken from saved point to saved point and `dt` is the\nsize of each time step.\n\"\"\"\nfunction integrate(z0, dt, nsteps, nt, method)\n    out = Vector{NTuple{4, Float64}}(undef, nt)\n    z = out[1] = z0\n    for i in 2:nt\n        for _ in 1:nsteps\n            z = timestep(z, dt, method)\n        end\n        out[i] = z\n    end\n    return out\nend\n\nintegrate(mat::AbstractMatrix, dt, nsteps, nt, method) = map(eachrow(mat)) do r\n    integrate((r[1], r[2], r[3], r[4]), dt, nsteps, nt, method)\nend","category":"page"},{"location":"guides/charged_particle/#Computing-the-Invariants","page":"Charged Particle","title":"Computing the Invariants","text":"","category":"section"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"Having gotten integration out of the way, we can move onto the invariants. For this system, the first invariant is given by","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"I_1 = int_gamma v(x) + A(x)  dx","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"where A(x) is the magnetic vector potential as a function of the position vector x. The second invariant is given by","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"I_2 = int_S omega_ij (q)  dz^i  dz^j","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"with the two-form omega given by","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"beginpmatrix\n 0  B  -1   0 \n-B  0   0  -1 \n 1  0   0   0 \n 0  1   0   0\nendpmatrix","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"In code, we can define these forms as follows.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"function oneform((x, y, vx, vy), ::Real, ::Any)\n    p = (vx, vy) .+ A(x, y)\n    @SVector [p[1], p[2], 0, 0]\nend\n\nfunction twoform(z, ::Real, ::Any)\n    b = B(z[1], z[2])\n    @SMatrix [ 0  b -1  0;\n              -b  0  0 -1;\n               1  0  0  0;\n               0  1  0  0]\nend","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"Forms always have the signature form(z, t, p), where z is the phasespace position, t is a time and p is an arbitrary parameter. To use these forms to compute our invariants, we must create the setup objects FirstPI and SecondPI and initialise the curve and surface we want in phasespace.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"pi1 = FirstPI{Float64, 4}(oneform, 1_000)\npi2 = SecondPI{Float64, 4}(twoform, 10_000)\n\nI1 = 0\npnts1 = getpoints(pi1) do θ\n    10 .* (0, 0, sinpi(2θ), cospi(2θ))\nend\n\nI2 = 1_000\npnts2 = getpoints(pi2) do x, y\n    10 .* (y - 0.5, x - 0.5, 0, 0)\nend","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"The curve is just a point in space, so the first integral invariant evaluates to zero. The second invariant is equal to 1000 since, it is equal to the magnetic field of strength 10 integrated over a 10 by 10 square. We can confirm this by computing the inital invariants.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"@assert isapprox(compute!(pi1, pnts1, 52.3, \"optional parameter\"), I1; atol=10^(-15))\n@assert isapprox(compute!(pi2, pnts2), I2; atol=10^(-11))","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"By default p is nothing and t is zero, but as shown in the first line we can also explicitly supply a time and parameter if the forms we defined earlier had required them. compute! used on a time series accepts an iterable of times and an arbitrary parameter.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"times = range(0.0; step=0.05 * 50, length=5)\n\nseries1 = integrate(pnts1, 0.05, 50, 5, Split2())\n@assert all(compute!(pi1, series1, times, (\"optional parameters\", 3.7, 42))) do I\n    abs(I - I1) < 10^(-13)\nend\n\nseries2 = integrate(pnts2, 0.05, 50, 5, Split2())\n@assert all(compute!(pi2, series2)) do I\n    abs(I - I2) < 10^(-11)\nend","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"Again, we can plot the results. The top two plots show the increasingly distorted curve and surface over time (projected onto x and y position components), while the bottom two plots show the error in the invariant over time for the two integration algorithms.","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"(Image: )","category":"page"},{"location":"guides/charged_particle/","page":"Charged Particle","title":"Charged Particle","text":"We see that RK4 does not preserve the non-canonical invariant while the splitting method does.","category":"page"},{"location":"#PoincareInvariants.jl","page":"Home","title":"PoincareInvariants.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Poincaré integral invariants provide useful diagnostics for analysing the long-time accuracy of numerical integrators for Hamiltonian dynamics and for distinguishing between symplectic and non-symplectic integrators. This package provides means for computing the first and second Poincaré integral invariant I_1 and I_2, which are defined in terms of the Lagrangian one- and two-form, vartheta and omega, respectively..","category":"page"},{"location":"#First-Poincaré-Invariant","page":"Home","title":"First Poincaré Invariant","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The one-form vartheta is a relative integral invariant, which means that the integral","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_1 = int_gamma vartheta_i (q)  dq^i","category":"page"},{"location":"","page":"Home","title":"Home","text":"stays constant in time when gamma is a closed loop in the configuration space mathcalM (a compact one-dimensional parametrized submanifold of mathcalM without boundary), that is advected along the solution of the dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figure shows examples of single trajectories of some samples of such a loop, as well as the temporal evolution of the whole loop following the dynamics of the guiding centre system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The loop gamma is parametrized by tau in 01), so that","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_1 (t) = int_0^1 vartheta_i (q_(tau)(t))  dfracd q_(tau)^idtau  dtau ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to compute this integral, we use N equidistant points in 01), so that the derivatives d q_(tau)  dtau can be efficiently computed via discrete Fourier transforms. The integral is approximated with the trapezoidal quadrature rule, which has spectral convergence on periodic domains (Trefethen & Weideman, 2014).","category":"page"},{"location":"#Second-Poincaré-Invariant","page":"Home","title":"Second Poincaré Invariant","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The two-form omega is an absolute integral invariant, which means that the integral","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_2 = int_S omega_ij (q)  dq^i  dq^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"stays constant in time when S is any compact two-dimensional parametrized submanifold of mathcalM, advected along the solution of the dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figure shows how an initially rectangular area in phasespace is advected by the dynamics of the guiding centre system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The area S is parametrized by (sigma tau) in 01^2, so that","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_2 (t) = int_0^1 int_0^1 omega_ij (q_(sigma tau) (t))  dfracdq_(sigma tau)^idsigma  dfracdq_(sigma tau)^jdtau  dsigma  dtau ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we represent the surface in terms of Chebyshev polynomials and thus use Chebyshev points for the discretization of the domain 01^2. The Chebyshev polynomials allow for an extremely accurate approximation of the surface, even if the latter becomes severely deformed.","category":"page"},{"location":"guides/diffeq/#Compute-Invariants-With-DifferentialEquations.jl","page":"DifferentialEquations.jl","title":"Compute Invariants With DifferentialEquations.jl","text":"","category":"section"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Before reading this, it's worth familiarising yourself with the Ensemble Simulations section of the DifferentialEquations.jl docs.","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"To compute invariants with DifferentialEquations.jl, we'll need to create a PIEnsembleProblem. This works as follows","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"PIEnsembleProblem(init, prob, pinv;\n    prob_func = (prob,i,repeat)->prob,\n    output_func = (sol,i) -> (sol,false),\n    reduction = (u,data,I)->(append!(u,data),false),\n    u_init = [], safetycopy = false\n)","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"init is the phasespace curve or surface parameterisation, which determines the initial conditions; prob is a problem from DifferentialEquations.jl, which specifies the time span and differential equation; pinv is an AbstractPoincareInvariant; prob_func allows the user to remake the problem for each trajectory in the ensemble; all further arguments are exactly like the EnsembleProblem type from DifferentialEquations.jl. You need not add a prob_func of your own to have the correct initial conditions. These will be entered automaticaly according ot the given setup objet and parameterisation. However, by default, the type of the initial condition is Vector{T}. If you want to use an ArrayPartion or a StaticArray or other type to represent a point in phase space, you should specify a prob_func to do the conversion.","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"All in all, this can look like so:","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"using OrdinaryDiffEq\nusing RecursiveArrayTools: ArrayPartition\nusing PoincareInvariants\n\ndt = 0.1\nprob = SecondOrderODEProblem((p, θ, params, t) -> [-sin(θ[1])], 0.0, 0.0, (0.0, 2.0))\npf(prob, i, repeat) = remake(prob; u0 = ArrayPartition((prob.u0[1:1], prob.u0[2:2])))\n\npi1 = CanonicalFirstPI{Float64, 2}(1_000)\nens_prob = PIEnsembleProblem(ϕ -> (sinpi(2ϕ), 3 * cospi(2ϕ)), prob, pi1; prob_func=pf)","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Once, we have our PIEnsembleProblem, we can call solve on it, just like the EnsembleProblem it wraps. The general pattern is","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"solve(prob::PIEnsembleProblem, alg, ensemblealg; kwargs...)","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Most arguments are simply passed to the solve function called on the wrapped EnsembleProblem. The trajectories keyword argument is already set as getpointnum(pinv) and the adaptive keyword is set to false by default. Otherwise the behaviour is identical. For our example, we would have","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"sol = solve(ens_prob, SymplecticEuler(), EnsembleSerial(); dt=dt)","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Finally, we can call compute! on the result, which returns a Vector{T} of invariant values for every saved timestep. You must make sure all trajectories save at the same time steps.","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"compute!(pi1, sol[, p])","category":"page"},{"location":"guides/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The times and points are taken from the solution. An optional parameter p may be given, which is passed to the differential form.","category":"page"}]
}
