<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pendulum · PoincareInvariants.jl</title><meta name="title" content="Pendulum · PoincareInvariants.jl"/><meta property="og:title" content="Pendulum · PoincareInvariants.jl"/><meta property="twitter:title" content="Pendulum · PoincareInvariants.jl"/><meta name="description" content="Documentation for PoincareInvariants.jl."/><meta property="og:description" content="Documentation for PoincareInvariants.jl."/><meta property="twitter:description" content="Documentation for PoincareInvariants.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PoincareInvariants.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><span class="tocitem">Guides</span><ul><li class="is-active"><a class="tocitem" href>Pendulum</a><ul class="internal"><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li><li><a class="tocitem" href="#Computing-the-Invariants"><span>Computing the Invariants</span></a></li></ul></li><li><a class="tocitem" href="../charged_particle/">Charged Particle</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../plans/">Plans</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guides</a></li><li class="is-active"><a href>Pendulum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Pendulum</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/PoincareInvariants.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/main/docs/src/guides/pendulum.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Pendulum"><a class="docs-heading-anchor" href="#Pendulum">Pendulum</a><a id="Pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#Pendulum" title="Permalink"></a></h1><p>In this tutorial we integrate the equations of motion for a pendulum and compute the first and second Poincaré integral invariants. First, we integrate the equations of motion then we can compute the invariants to check whether they are in fact conserved. The full script to generate the plots and do the computations shown here can be found at <a href="https://github.com/JuliaGNI/PoincareInvariants.jl/examples/pendulum.jl">examples/pendulum.jl</a>.</p><p>Let us begin. We will need to import <a href="https://github.com/JuliaGNI/PoincareInvariants.jl">PoincareInvariants.jl</a>.</p><pre><code class="language-julia hljs">using PoincareInvariants</code></pre><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p>We&#39;ll quickly write our own integration code here for simplicity. This library can be used with <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>. For the purposes of this tutorial we pick a unit system, such that gravity, mass and length are equal to one. The equations of motion for the angle <span>$\theta$</span> and angular momentum <span>$p$</span> for a simple pendulum are therefore given by</p><p class="math-container">\[\dot{\theta} = p,\; \dot{p} = -\sin{\theta}\]</p><p>To integrate these equations of motion we will compare the <a href="https://en.wikipedia.org/wiki/Backward_Euler_method">backward Euler method</a>, the <a href="https://en.wikipedia.org/wiki/Semi-implicit_Euler_method">symplectic Euler method</a> and <em>the</em> <a href="https://en.wikipedia.org/wiki/Runge–Kutta_methods#The_Runge–Kutta_method">Runge-Kutta method (RK4)</a>. The following shows the implementations for stepping forward by one time step for each method.</p><pre><code class="language-julia hljs">pendulum((θ, p)) = (p, -sin(θ))

struct BackwardEuler end
function timestep((θ, p), dt, ::BackwardEuler)
    sinθ, cosθ = sincos(θ)
    p = (p - dt * sinθ) / (1 + dt^2 * cosθ)
    return θ + dt * p, p
end

struct SymplecticEuler end
function timestep((θ, p), dt, ::SymplecticEuler)
    θ = θ + dt * p  # update position
    p = p - dt * sin(θ)  # update momentum
    return θ, p
end

struct RK4 end
function timestep((θ, p), dt, ::RK4)
    k1 = pendulum((θ, p))
    k2 = pendulum((θ, p) .+ 0.5 .* dt .* k1)
    k3 = pendulum((θ, p) .+ 0.5 .* dt .* k2)
    k4 = pendulum((θ, p) .+ dt .* k3)
    return (θ, p) .+ (dt/6) .* (k1 .+ 2 .* k2 .+ 2 .* k3 .+ k4)
end</code></pre><p>We&#39;ll also need some code to step many times and save the result.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    integrate((θ₀, p₀), dt, nsteps, nt, method)

start at `(θ₀, p₀)` and integrate the equations of motion using `method`.
Returns the timeseries as a vector of tuples. `nt` points are saved,
`nsteps` steps are taken from saved point to saved point and `dt` is the
size of each time step.
&quot;&quot;&quot;
function integrate((θ₀, p₀), dt, nsteps, nt, method)
    out = Vector{Tuple{Float64, Float64}}(undef, nt)
    (θ, p) = out[1] = (θ₀, p₀)
    for i in 2:nt
        for _ in 1:nsteps
            (θ, p) = timestep((θ, p), dt, method)
        end
        out[i] = (θ, p)
    end
    return out
end</code></pre><h2 id="Computing-the-Invariants"><a class="docs-heading-anchor" href="#Computing-the-Invariants">Computing the Invariants</a><a id="Computing-the-Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Invariants" title="Permalink"></a></h2><p>The first invariant is the integral</p><p class="math-container">\[I_{1} = \int_{\gamma} p(\theta) \, d\theta\]</p><p>which remains invariant as each point <span>$(\theta(t), p(t))$</span> on the curve <span>$\gamma$</span> moves in phasespace according to the above equations of motion. The second invariant is the integral</p><p class="math-container">\[I_{2} = \int_{S} d\theta \, dp\]</p><p>which remains invariant as each point <span>$(\theta(t), p(t))$</span> on the surface <span>$S$</span> moves in phasespace according to the above equations of motion.</p><p>However, our numerical integration methods only approximate the true dynamics. So we might ask whether the two invariants are preserved, even when integrated only approximately. To answer this question we compute the two integral invariants numerically. The general approach to computing the invariants goes as follows.</p><ol><li>Approximate the intial curve or surface in phasespace with a finite number of points.</li><li>Compute the initial curve or surface integral using the approximation given by the set of points.</li><li>Move the set of points in phasespace by integrating the equations of motion for each.</li><li>Compute the integral invariant again using the moved set of points to approximate the curve or surface.</li></ol><p>In code, we start by initialising the setup objects <code>CanonicalFirstPI</code> and <code>CanonicalSecondPI</code> to preallocate everything we&#39;ll need for further computation.</p><pre><code class="language-julia hljs">pi1 = CanonicalFirstPI{Float64, 2}(500)
pi2 = CanonicalSecondPI{Float64, 2}(10_000)</code></pre><p><code>Float64</code> refers to the numeric type to use for calculations. For example, you could switch to <a href="https://github.com/JuliaMath/DoubleFloats.jl">DoubleFloats.jl</a> for improved accuracy. The <code>2</code> refers to the dimension of phasespace. In our case, that&#39;s two, since the pendulum has two degrees of freedom, namely the angle and angular momentum. Finally, the numbers <code>1_000</code> and <code>10_000</code> refer to how many points to use to approximate the curve and surface in phasespace. The exact number of points actually used depends on the implementation used and may be inspected with <a href="../../reference/#PoincareInvariants.getpointnum"><code>getpointnum</code></a></p><pre><code class="language-julia hljs">@assert 500 ≤ getpointnum(pi1) ≤ 750
@assert 10_000 ≤ getpointnum(pi2) ≤ 15_000</code></pre><p>Next, we&#39;ll need to initialise the curve and surface. For the first invariant, we use a unit circle stretched by a factor of three as our curve. The corresponding invariant is <span>$3\pi$</span>. For the second invariant, we use a four by four square centered at the origin. The corresponding invariant is <span>$16$</span>.  In code, this looks like</p><pre><code class="nohighlight hljs">I1 = 3π
pnts1 = getpoints(pi1) do ϕ
    sinpi(2ϕ), 3 * cospi(2ϕ)
end

I2 = 16
pnts2 = getpoints(pi2) do x, y
    4 .* (x, y) .- 2
end</code></pre><p><a href="../../reference/#PoincareInvariants.getpoints"><code>getpoints</code></a> takes a parameterisation as its first argument and the setup object as its second argument. It returns a matrix, where each row is a point. The parameterisation must accept a value in the domain and maps it to a point in phase space, representing a point on the curve or surface to be integrated over. For the first invariant the domain is just <span>$[0,1]$</span> and the parameterisation must be periodic. For the second invariant the domain is <span>$[0,1]^{2}$</span>, so the corresponding parameterisation must accept two inputs. The exact points in the domain at which the parameterisations are evaluated changes depending on the underlying implementation. The points used by the current implementation may be inspected using <a href="../../reference/#PoincareInvariants.getpoints"><code>getpoints</code></a> without a function argument.</p><pre><code class="language-julia hljs">getpoints(pi1)
getpoints(pi2)</code></pre><p>Below is a plot of the initial points in phasespace.</p><p><img src="../pendulum_init.png" alt/></p><p>Having initialised our initial curve and surface, we may compute the invariant as follows.</p><pre><code class="nohighlight hljs">@assert isapprox(compute!(pi1, pnts1), I1; atol=10eps())
@assert isapprox(compute!(pi2, pnts2), I2; atol=10eps())</code></pre><p>Now we&#39;ll want to integrate the equations of motion. To do this, let&#39;s introduce a quick helper function to integrate all points or rows.</p><pre><code class="language-julia hljs">integrate(mat::AbstractMatrix, dt, nsteps, nt, method) = map(eachrow(mat)) do pnt
    integrate((pnt[1], pnt[2]), dt, nsteps, nt, method)
end</code></pre><p>As it turns out, <code>compute!</code> will work out of the box with a vector of time series like this. So we can just do</p><pre><code class="language-julia hljs">series1 = integrate(pnts1, 0.05, 15, 5, SymplecticEuler())
@assert all(compute!(pi1, series1)) do I
    abs(I - I1) &lt; 10^(-14)
end

series2 = integrate(pnts2, 0.05, 15, 5, SymplecticEuler())
@assert all(compute!(pi2, series2)) do I
    abs(I - I2) &lt; 10^(-13)
end</code></pre><p>When <code>compute!</code> is given time series like this it will calculate the invariant for each time and return a <code>Vector</code> of the invariant values. Below is a plot of the points in phasespace and invariants over time. The left column corresponds to the first invariant and the right corresponds to the second. The top two plots show the increasingly distorted curve and surface over time, while the bottom two plots show the error in the invariant over time for different integration algorithms.</p><p><img src="../pendulum.png" alt/></p><p>Given the data shown above, we can confirm that <code>SymplecticEuler</code> is in fact symplectic and preserves the two invariants very well, while the other two methods are not symplectic and hence do not conserve the associated invariants. These data are all the more impressive when you consider the significant distortion of the initial curve and surface and that <code>SymplecticEuler</code> is a first order method whereas <code>RK4</code> is a fourth order method.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/">« Theory</a><a class="docs-footer-nextpage" href="../charged_particle/">Charged Particle »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 7 November 2024 15:52">Thursday 7 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
