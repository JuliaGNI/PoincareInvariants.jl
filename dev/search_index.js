var documenterSearchIndex = {"docs":
[{"location":"canonical_symplectic_structures/#Canonical-Symplectic-Structures","page":"Canonical Symplectic Structures","title":"Canonical Symplectic Structures","text":"","category":"section"},{"location":"canonical_symplectic_structures/","page":"Canonical Symplectic Structures","title":"Canonical Symplectic Structures","text":"CurrentModule = PoincareInvariants.CanonicalSymplecticForms\nDocTestSetup = quote\n    using PoincareInvariants.CanonicalSymplecticForms\nend","category":"page"},{"location":"canonical_symplectic_structures/","page":"Canonical Symplectic Structures","title":"Canonical Symplectic Structures","text":"This module currently contains the type CanonicalSymplecticMatrix, which satisifes the AbstractMatrix interface and has an optimised LinearAlgebra.dot method to compute the vector matrix vector product.","category":"page"},{"location":"canonical_symplectic_structures/","page":"Canonical Symplectic Structures","title":"Canonical Symplectic Structures","text":"CanonicalSymplecticMatrix","category":"page"},{"location":"canonical_symplectic_structures/#PoincareInvariants.CanonicalSymplecticForms.CanonicalSymplecticMatrix","page":"Canonical Symplectic Structures","title":"PoincareInvariants.CanonicalSymplecticForms.CanonicalSymplecticMatrix","text":"CanonicalSymplecticMatrix{T}(n::Integer)\n\nconstructs a canonical symplectic matrix of size (n, n) with eltype T. n must be even and positive. See the examples to see the form of the canonical symplectic matrix as defined here.\n\nExamples\n\njulia> CanonicalSymplecticMatrix(4)\n4×4 CanonicalSymplecticMatrix{Int64}:\n 0  0  -1   0\n 0  0   0  -1\n 1  0   0   0\n 0  1   0   0\n\njulia> CanonicalSymplecticMatrix{Int32}(6)\n6×6 CanonicalSymplecticMatrix{Int32}:\n 0  0  0  -1   0   0\n 0  0  0   0  -1   0\n 0  0  0   0   0  -1\n 1  0  0   0   0   0\n 0  1  0   0   0   0\n 0  0  1   0   0   0\n\n\n\n\n\n","category":"type"},{"location":"first_poincare_invariants/#First-Poincaré-Invariants","page":"First Poincaré Invariants","title":"First Poincaré Invariants","text":"","category":"section"},{"location":"padua_transforms/#Padua-Transforms","page":"Padua Transforms","title":"Padua Transforms","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"CurrentModule = PoincareInvariants.SecondChebyshevPlans.PaduaTransforms\nDocTestSetup = quote\n    using PoincareInvariants.SecondChebyshevPlans.PaduaTransforms\nend","category":"page"},{"location":"padua_transforms/#Introduction","page":"Padua Transforms","title":"Introduction","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"The Padua transform yields coefficients a_ij used to approximate a bivariate function f(x y) with","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"f(x y)  sum_i j a_ij  T_i(y)  T_j(x)","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"where T_n(x) = cos(n arccos(x)) is the nth Chebyshev polynomial. For reference, the first few Chebyshev polynomials are","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"beginaligned\nT_0(x) = 1 \nT_1(x) = x \nT_2(x) = 2x^2 - 1 \nT_3(x) = 4x^3 - 3x \nT_4(x) = 8x^4 - 8x^2 + 1\nendaligned","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"The inverse transform takes the coefficients a_ij and returns the function f(x y) evaluated at the so called Padua points.","category":"page"},{"location":"padua_transforms/#Basic-Usage","page":"Padua Transforms","title":"Basic Usage","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Start by evaluating a function on the Padua points. Here we approximate the function with a polynomial of total degree 3. The total degree is the degree of the largest polynomial in x plus the degree of the largest polynomial in y.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> vals = getpaduapoints(3) do x, y\n           y * (2x^2 - 1) + 5 * x * y + 2.5\n       end\n10-element Vector{Float64}:\n  8.5\n  2.5\n -3.5\n  3.914213562373095\n  1.0857864376269049\n -0.5\n  2.5\n  5.5\n -0.3284271247461903\n  5.32842712474619","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Then create a PaduaTransformPlan and apply the paduatransform! to get the Chebyshev coefficeints a_ij.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> plan = PaduaTransformPlan{Float64}(3);\n\njulia> coeffs = paduatransform!(zeros(4, 4), plan, vals)\n4×4 Matrix{Float64}:\n 2.5  0.0  0.0  0.0\n 0.0  5.0  1.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"We can go back to values using an InvPaduaTransformPlan and applying invpaduatransform!","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> invplan = InvPaduaTransformPlan{Float64}(3);\n\njulia> out = invpaduatransform!(Vector{Float64}(undef, getpaduanum(3)), invplan, coeffs)\n10-element Vector{Float64}:\n  8.5\n  2.5\n -3.5\n  3.914213562373095\n  1.0857864376269049\n -0.5\n  2.5\n  5.5\n -0.3284271247461903\n  5.32842712474619\n\njulia> out ≈ vals\ntrue","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"where we used getpaduanum to get the number of Padua points and coefficients corresponding to total degree 3.","category":"page"},{"location":"padua_transforms/#The-Algorithm-–-Step-by-Step","page":"Padua Transforms","title":"The Algorithm – Step by Step","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"To obtain the coefficients a_ij we need to evaluate the function f at some points (x_l y_k) and evaluate","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"a_ij = sum_k l  f(x_l y_k)  T_i(y_k)  T_j(x_l)","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"If we let x_l = cosfraclπn and y_k = cosfrackπm, we have","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"a_ij = sum_k l  f(cosfraclπn cosfrackπm)  T_i(cosfrackπm)  T_j(cosfraclπn)","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"which simplifies to","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"a_ij = sum_k l  f(cosfraclπn cosfrackπm)  cosfracikπm  cosfracjlπn","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"because of the definition of the Chebyshev polynomials as T_n(x) = cos(n arccos(x)). The expression above looks like a discrete cosine transform, which is what we will use to implement the Padua transform. Note, that the formula above is not quite exact since we need to apply a weighting factor to the coefficients. For further reading on the Padua Transform, please see the following:","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"For details on the Padua points as good nodes for polynomial interpolation: Marco Caliari, Stefano De Marchi, Marco Vianello. Bivariate polynomial interpolation on the square at new nodal sets","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"and for details on the implementation of the transform via a discrete cosine transform: Marco Caliari, Stefano De Marchi, Alvise Sommariva, Marco Vianello. Padua2DM: fast interpolation and cubature at the Padua points in Matlab/Octave","category":"page"},{"location":"padua_transforms/#The-Padua-Points","page":"Padua Transforms","title":"The Padua Points","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"There are multiple ways to define the set of Padua points. For our purposes we will use","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"textrmPad_n = (cosfracjπn cosfraciπn + 1)    0  j  n  0  i  n + 1  i - j  textrmeven ","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"where n is the total degree of the polynomial we can approximate using the Padua points. To generate the Padua points we can use the function getpaduapoints as follows","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> getpaduapoints(3)\n10×2 Matrix{Float64}:\n  1.0   1.0\n  1.0   0.0\n  1.0  -1.0\n  0.5   0.707107\n  0.5  -0.707107\n -0.5   1.0\n -0.5   0.0\n -0.5  -1.0\n -1.0   0.707107\n -1.0  -0.707107","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Using do block syntax we can evaluate a function on the Padua points.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> vals = getpaduapoints(3) do x, y\n                  y * (2x^2 - 1) + 5 * x * y + 2.5\n              end\n10-element Vector{Float64}:\n  8.5\n  2.5\n -3.5\n  3.914213562373095\n  1.0857864376269049\n -0.5\n  2.5\n  5.5\n -0.3284271247461903\n  5.32842712474619","category":"page"},{"location":"padua_transforms/#The-Padua-Transform","page":"Padua Transforms","title":"The Padua Transform","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Having evaluated our function on the Padua points, we can perform the transform. First, we initialise a transform plan.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> plan = PaduaTransformPlan{Float64}(3);","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"The transform consists of writing vals into plan.vals, applying a fast fourier transform and weighting the resulting coefficients to obtain the Chebyshev coefficients. We start by writting values into the values matrix using tovalsmat!.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> PaduaTransforms.tovalsmat!(plan.vals, vals, 3)\n5×4 Matrix{Float64}:\n  8.5  0.0      -0.5   0.0\n  0.0  3.91421   0.0  -0.328427\n  2.5  0.0       2.5   0.0\n  0.0  1.08579   0.0   5.32843\n -3.5  0.0       5.5   0.0","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"vals are written into the matrix plan.vals such that the entry plan.vals[i+1, j+1] corresponds to the Padua point (cosfracjπn cosfraciπn + 1). However, since the Padua points are only those points with i-j even, all entries corresponding to i-j odd are left out. These off grid entries must be filled with 0. Next, we can apply the discrete cosine transform and weight! the coefficients to obtain the Chebyshev coefficients.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> plan.dctplan * plan.vals\n5×4 Matrix{Float64}:\n 60.0   0.0   0.0   0.0\n  0.0  30.0   6.0   0.0\n  0.0   0.0   0.0   0.0\n  0.0   6.0  30.0   0.0\n  0.0   0.0   0.0  60.0\n\njulia> PaduaTransforms.weight!(plan.vals, 3)\n5×4 Matrix{Float64}:\n 2.5  0.0  0.0  0.0\n 0.0  5.0  1.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  1.0  5.0  0.0\n 0.0  0.0  0.0  2.5","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"The weighting factor we apply to the coefficients is","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"w = frac1n(n+1)  begincases\n    frac12  textrmif on vertex   \n    1            textrmif on edge     \n    2            textrmif in interior \nendcases","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Finally, we write those coefficients corresponding to a total degree of 3 or lower (the upper left triangular) into the output.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> coeffs = zeros(4, 4)\n4×4 Matrix{Float64}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> PaduaTransforms.fromcoeffsmat!(coeffs, plan.vals, 3)\n4×4 Matrix{Float64}:\n 2.5  0.0  0.0  0.0\n 0.0  5.0  1.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0","category":"page"},{"location":"padua_transforms/#The-Inverse-Padua-Transform","page":"Padua Transforms","title":"The Inverse Padua Transform","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"If we have a set of Chebyshev coefficients and want to obtain the values of the corresponding Chebyshev polynomial on the Padua points, we must use the inverse Padua transform. Again, we start with a plan and write our coefficients into plan.coeffs.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> invplan = InvPaduaTransformPlan{Float64}(3);\n\njulia> PaduaTransforms.tocoeffsmat!(invplan.coeffs, coeffs)\n5×4 Matrix{Float64}:\n 2.5  0.0  0.0  0.0\n 0.0  5.0  1.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Next, we weight the coefficients using invweight! and apply a discrete cosine transform.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> PaduaTransforms.invweight!(invplan.coeffs)\n5×4 Matrix{Float64}:\n 2.5  0.0   0.0   0.0\n 0.0  1.25  0.25  0.0\n 0.0  0.0   0.0   0.0\n 0.0  0.0   0.0   0.0\n 0.0  0.0   0.0   0.0\n\njulia> invplan.dctplan * invplan.coeffs\n5×4 Matrix{Float64}:\n  8.5      4.5      -0.5      -1.5\n  6.74264  3.91421   0.37868  -0.328427\n  2.5      2.5       2.5       2.5\n -1.74264  1.08579   4.62132   5.32843\n -3.5      0.5       5.5       6.5","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"invweight! applies the weighting","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"w = begincases\n    1            textrmif on vertex   \n    frac12  textrmif on edge     \n    frac14  textrmif in interior \nendcases","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"Finally, we copy over those values corresponding to i-j even and we have our values back.","category":"page"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"julia> out = PaduaTransforms.fromvalsmat!(Vector{Float64}(undef, getpaduanum(3)), invplan.coeffs, 3)\n10-element Vector{Float64}:\n  8.5\n  2.5\n -3.5\n  3.914213562373095\n  1.0857864376269049\n -0.5\n  2.5\n  5.5\n -0.3284271247461903\n  5.32842712474619\n\njulia> vals ≈ out\ntrue","category":"page"},{"location":"padua_transforms/#Reference","page":"Padua Transforms","title":"Reference","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"PaduaTransforms","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms","text":"PaduaTransforms\n\nan implementation of the Padua transform and its inverse via the fast Fourier transform.\n\n\n\n\n\n","category":"module"},{"location":"padua_transforms/#Padua-Points","page":"Padua Transforms","title":"Padua Points","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"getpaduapoints","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getpaduapoints","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getpaduapoints","text":"getpaduapoints([f::Function,], [T=Float64,] n)\n\nevaluates the function f on the Padua points (of type T) for degree n.\n\nIf no function f is provided, getpaduapoints returns a matrix containing the x and y components of the paduapoints as columns. If f returns a single value, getpaduapoints returns a Vector{T}. If f returns a tuple or other iterable, getpaduapoints returns a Matrix{T} where the i-th column represents the i-th entry in f applied to all the Padua points.\n\nExamples\n\njulia> getpaduapoints(2)\n6×2 Matrix{Float64}:\n  1.0   1.0\n  1.0  -0.5\n  0.0   0.5\n  0.0  -1.0\n -1.0   1.0\n -1.0  -0.5\n\njulia> getpaduapoints(Float32, 1)\n3×2 Matrix{Float32}:\n  1.0   1.0\n  1.0  -1.0\n -1.0   0.0\n\njulia> getpaduapoints(Float32, 2) do x, y; x*y; end\n6-element Vector{Float32}:\n  1.0\n -0.50000006\n  0.0\n -0.0\n -1.0\n  0.50000006\n\njulia> getpaduapoints(2) do x, y; x*y, 5*x*y; end\n6×2 Matrix{Float64}:\n  1.0   5.0\n -0.5  -2.5\n  0.0   0.0\n -0.0  -0.0\n -1.0  -5.0\n  0.5   2.5\n\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#Numbers-of-Coefficients-and-Points","page":"Padua Transforms","title":"Numbers of Coefficients and Points","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"getpaduanum\ngetdegree\nnextpaduanum\nnextdegree","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getpaduanum","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getpaduanum","text":"getpaduanum(n)\n\ncalculates number of Padua points needed to approximate a function using Chebyshev polynomials up to total degree n. This number is equal to the number of coefficients. The formula is\n\nN = (n + 1)  (n + 2)  2\n\nExamples\n\njulia> getpaduanum(13)\n105\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getdegree","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.getdegree","text":"getdegree(N)\n\ncalculates total degree, given the number of coefficients or Padua points N. Throws an error if N is not a possible number of Padua points. The formula is\n\nn = fracsqrt1 + 8N - 32\n\nExamples\n\njulia> getdegree(105)\n13\n\njulia> getdegree(104)\nERROR: ArgumentError: number of Padua points or coeffs must be (n + 1) * (n + 2) ÷ 2\n[...]\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.nextpaduanum","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.nextpaduanum","text":"nextpaduanum(N)\n\nget next valid number of Padua points ≥ N.\n\nExamples\n\njulia> nextpaduanum(104)\n105\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.nextdegree","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.nextdegree","text":"nextdegree(N)\n\nget degree of nextpaduanum(N).\n\nExamples\n\njulia> nextdegree(104)\n13\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#Padua-Transform","page":"Padua Transforms","title":"Padua Transform","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"PaduaTransformPlan\npaduatransform!","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.PaduaTransformPlan","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.PaduaTransformPlan","text":"PaduaTransformPlan{T}(n::Integer)\n\ncreate plan to compute coefficients of Chebyshev polynomials in 2D up to total degree n using the Padua transform.\n\n\n\n\n\n","category":"type"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.paduatransform!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.paduatransform!","text":"paduatransform!(coeffs, P::PaduaTransformPlan, vals[, lex])\n\nobtain coefficients of Chebyshev polynomials on 2D via the Padua transform, given values vals evaluated at the Padua points. Coefficients will be written into coeffs, which should either be a matrix, a vector or an iterable of either.\n\nIf a matrix of vals and a corresponding iterable of coeffs matrixes or vectors is given, each vals column will be transformed seperately in a multidimensional Padua transform.\n\nlex determines the order in which coefficients are written into out if out is a vector. See fromcoeffsmat! for details.\n\nwarning: Warning\nif coeffs is a matrix, make sure that all entries in the lower right diagonal are zero as these will not get overwritten.\n\nExamples\n\njulia> plan = PaduaTransformPlan{Float64}(2);\n\njulia> f(x, y) = 3 + 4x + 5 * x*y, 6 + 7y\nf (generic function with 1 method)\n\njulia> vals = getpaduapoints(f, 2)\n6×2 Matrix{Float64}:\n 12.0  13.0\n  4.5   2.5\n  3.0   9.5\n  3.0  -1.0\n -6.0  13.0\n  1.5   2.5\n\njulia> paduatransform!(zeros(3, 3), plan, vals[:, 1])\n3×3 Matrix{Float64}:\n 3.0  4.0  0.0\n 0.0  5.0  0.0\n 0.0  0.0  0.0\n\njulia> paduatransform!(zeros(6), plan, vals[:, 2], Val(true))\n6-element Vector{Float64}:\n 6.0\n 0.0\n 7.0\n 0.0\n 0.0\n 0.0\n\njulia> paduatransform!((zeros(3, 3), zeros(3, 3)), plan, vals)\n([3.0 4.0 0.0; 0.0 5.0 0.0; 0.0 0.0 0.0], [6.0 0.0 0.0; 7.0 0.0 0.0; 0.0 0.0 0.0])\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#Inverse-Padua-Transform","page":"Padua Transforms","title":"Inverse Padua Transform","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"InvPaduaTransformPlan\ninvpaduatransform!","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.InvPaduaTransformPlan","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.InvPaduaTransformPlan","text":"InvPaduaTransformPlan{T}(n::Integer)\n\ncreate plan to compute values on Padua points, given coefficients of Chebyshev polynomials up to total degree n.\n\n\n\n\n\n","category":"type"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.invpaduatransform!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.invpaduatransform!","text":"invpaduatransform!(vals::AbstractVector, IP::InvPaduaTransformPlan, coeffs::AbstractMatrix)\n\nevaluates the polynomial defined by the coefficients of Chebyshev polynomials coeffs on the Padua points using the inverse transform plan IP and writes the resulting values into vals.\n\nIf a vals matrix and a corresponding iterable of coeffs matrixes is given, each coeffs matrix will be transformed seperately into a column in vals.\n\nExamples\n\njulia> iplan = InvPaduaTransformPlan{Float64}(2);\n\njulia> coeffs = [3 4 0; 0 5 0; 0 0 0]\n3×3 Matrix{Int64}:\n 3  4  0\n 0  5  0\n 0  0  0\n\njulia> invpaduatransform!(zeros(6), iplan, coeffs)\n6-element Vector{Float64}:\n 12.0\n  4.5\n  3.0\n  3.0\n -6.0\n  1.5\n\njulia> getpaduapoints(2) do x, y; 3 + 4x + 5 * x*y; end\n6-element Vector{Float64}:\n 12.0\n  4.5\n  3.0\n  3.0\n -6.0\n  1.4999999999999996\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#Internals","page":"Padua Transforms","title":"Internals","text":"","category":"section"},{"location":"padua_transforms/","page":"Padua Transforms","title":"Padua Transforms","text":"paduapoint\nispadua\ntovalsmat!\nweight!\nfromcoeffsmat!\ntocoeffsmat!\ninvweight!\nfromvalsmat!","category":"page"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.paduapoint","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.paduapoint","text":"paduapoint(T::Type, j::Integer, i::Integer, n::Integer)\n\nreturns the Padua point z_ij, where\n\nz_ij = (cosfracjπn cosfraciπn+1)\n\nNote, that only points with i-j even are actually Padua points. Check with ispadua.\n\nExamples\n\njulia> [PaduaTransforms.paduapoint(Float32, x, y, 1) for y in 0:1+1, x in 0:1]\n3×2 Matrix{Tuple{Float32, Float32}}:\n (1.0, 1.0)   (-1.0, 1.0)\n (1.0, 0.0)   (-1.0, 0.0)\n (1.0, -1.0)  (-1.0, -1.0)\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.ispadua","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.ispadua","text":"ispadua(i, j)\n\nreturns if paduapoint at position (i, j) is a Padua point.\n\nExamples\n\njulia> pointornothing(i, j, n) = PaduaTransforms.ispadua(i, j) ? PaduaTransforms.paduapoint(Float64, j, i, n) : nothing\npointornothing (generic function with 1 method)\n\njulia> [pointornothing(y, x, 2) for y in 0:3, x in 0:2]\n4×3 Matrix{Union{Nothing, Tuple{Float64, Float64}}}:\n (1.0, 1.0)   nothing      (-1.0, 1.0)\n nothing      (0.0, 0.5)   nothing\n (1.0, -0.5)  nothing      (-1.0, -0.5)\n nothing      (0.0, -1.0)  nothing\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.tovalsmat!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.tovalsmat!","text":"tovalsmat!(mat::Matrix, from::AbstractVector, degree::Integer)\n\nwrite values of function evaluated at Padua points from from to matrix mat.\n\nExamples\n\njulia> PaduaTransforms.tovalsmat!(ones(3 + 2, 3 + 1), 1:getpaduanum(3), 3)\n5×4 Matrix{Float64}:\n 1.0  0.0  6.0   0.0\n 0.0  4.0  0.0   9.0\n 2.0  0.0  7.0   0.0\n 0.0  5.0  0.0  10.0\n 3.0  0.0  8.0   0.0\n\njulia> PaduaTransforms.tovalsmat!(ones(2 + 2, 2 + 1), 1:getpaduanum(2), 2)\n4×3 Matrix{Float64}:\n 1.0  0.0  5.0\n 0.0  3.0  0.0\n 2.0  0.0  6.0\n 0.0  4.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.weight!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.weight!","text":"weight!(mat::AbstractMatrix, degree::Integer)\n\nweight fourier coefficients to obtain Chebyshev coefficients as part of a paduatransform!. The weighting factor applied to the coefficients is\n\nw = frac1n(n+1)  begincases\n    frac12  textrmif on vertex   \n    1            textrmif on edge    \n    2            textrmif in interior \nendcases\n\nExamples\n\njulia> weight!(ones(4+2, 4+1), 4)\n6×5 Matrix{Float64}:\n 0.025  0.05  0.05  0.05  0.025\n 0.05   0.1   0.1   0.1   0.05\n 0.05   0.1   0.1   0.1   0.05\n 0.05   0.1   0.1   0.1   0.05\n 0.05   0.1   0.1   0.1   0.05\n 0.025  0.05  0.05  0.05  0.025\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.fromcoeffsmat!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.fromcoeffsmat!","text":"fromcoeffsmat!(to::AbstractVector, mat::Matrix, degree::Integer, ::Val{lex})\n\nwrite Chebyshev coefficients from mat into vector to. lex::Bool determines whether coefficients should be written in lexigraphical order or not. The lower right triangle does not get written into to. These would represent greater polynomial degrees than degree.\n\nIf lex is Val(true) the coefficients correspond to the following basis polynomials\n\nT_0(x) T_0(y) T_1(x) T_0(y) T_0(x) T_1(y) T_2(x) T_0(y) T_1(x) T_1(y) T_0(x) T_2(y) \n\nelse if lex is Val(false) they correspond to\n\nT_0(x) T_0(y) T_0(x) T_1(y) T_1(x) T_0(y) T_0(x) T_2(y) T_1(x) T_1(y) T_2(x) T_0(y) \n\nExamples\n\njulia> mat = [(x, y) for y in 0:2+1, x in 0:2]\n4×3 Matrix{Tuple{Int64, Int64}}:\n (0, 0)  (1, 0)  (2, 0)\n (0, 1)  (1, 1)  (2, 1)\n (0, 2)  (1, 2)  (2, 2)\n (0, 3)  (1, 3)  (2, 3)\n\njulia> to1 = similar(mat, getpaduanum(2)); to2 = similar(mat, getpaduanum(2));\n\njulia> fromcoeffsmat!(to1, mat, 2, Val(true))\n6-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (1, 0)\n (0, 1)\n (2, 0)\n (1, 1)\n (0, 2)\n\njulia> fromcoeffsmat!(to2, mat, 2, Val(false))\n6-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (0, 1)\n (1, 0)\n (0, 2)\n (1, 1)\n (2, 0)\n\n\n\n\n\nfromcoeffsmat!(to::AbstractMatrix, mat::Matrix, degree::Integer)\n\ncopy Chebyshev coefficients from mat to to without copying coefficients coresponding to total degree greater than degree.\n\nExamples\n\njulia> PaduaTransforms.fromcoeffsmat!(zeros(4, 4), reshape(1:20, 5, 4), 3)\n4×4 Matrix{Float64}:\n 1.0  6.0  11.0  16.0\n 2.0  7.0  12.0   0.0\n 3.0  8.0   0.0   0.0\n 4.0  0.0   0.0   0.0\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.tocoeffsmat!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.tocoeffsmat!","text":"tocoeffsmat!(mat::AbstractMatrix, coeffs::AbstractMatrix)\n\nwrites coefficients in coeffs into matrix mat for the invpaduatransform!.\n\nExamples\n\njulia> PaduaTransforms.tocoeffsmat!(zeros(5, 4), reshape(1:16, 4, 4))\n5×4 Matrix{Float64}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n 0.0  0.0   0.0   0.0\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.invweight!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.invweight!","text":"invweight!(coeffs::AbstractMatrix)\n\nweight Chebyshev coefficients before the Fourier transform for the invpaduatransform!. using the weighting\n\nw = begincases\n    1             textrmif on vertex   \n    frac12  textrmif on edge     \n    frac14  textrmif in interior \nendcases\n\nExamples\n\njulia> PaduaTransforms.invweight!(ones(5, 5))\n5×5 Matrix{Float64}:\n 1.0  0.5   0.5   0.5   1.0\n 0.5  0.25  0.25  0.25  0.5\n 0.5  0.25  0.25  0.25  0.5\n 0.5  0.25  0.25  0.25  0.5\n 1.0  0.5   0.5   0.5   1.0\n\n\n\n\n\n","category":"function"},{"location":"padua_transforms/#PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.fromvalsmat!","page":"Padua Transforms","title":"PoincareInvariants.SecondChebyshevPlans.PaduaTransforms.fromvalsmat!","text":"fromvalsmat!(to::AbstractVector, mat::AbstractMatrix, n::Integer)\n\nwrite values from mat into the vector to after an invpaduatransform! of total degree n.\n\n\n\n\n\n","category":"function"},{"location":"second_poincare_invariants/#Second-Poincaré-Invariants","page":"Guide","title":"Second Poincaré Invariants","text":"","category":"section"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"CurrentModule = PoincareInvariants\nDocTestSetup = quote\n    using PoincareInvariants\nend","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"For this example, we will calculate the Second Poincaré Invariant for a simple example. We will be working in 2D phase space for simplicity. To approximate our surface, we will use approximately 500 points.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> D = 2; N = 500;","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"To calculate the second poincare invariant, we will need to define the two-form Omega, the integral invariant.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> ω(z, t, p) = CanonicalSymplecticMatrix(D);","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"The two-form is just a D x D matrix. In this case it is the canonical symplectic matrix. Here, we have defined it as a function of the phase space position z, time t and arbitrary parameter p. In future it will also be possible to use a constant matrix or an in-place function.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"Now, we can initialise the setup object used to calculate the invariant.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> pinv = SecondPoincareInvariant{Float64, D}(ω, N);","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"The type Float64 specifies that the final result as well as all intermediate calculations will use the type Float64. The number N specifies the approximate number of points to be used to approximate the surface. The exact number depends on implementation details. The type of ω signals it is not a constant matrix.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"The setup object contains the two-form, the dimension of the phase space and the number of points used to approximate the surface. These properties can be probed using the functions getform, getdim and getpointnum. The setup object also contains a plan object which is used to preallocate memory and setup the computation.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> getform(pinv)\nω (generic function with 1 method)\n\njulia> getdim(pinv)\n2\n\njulia> getpointnum(pinv)\n528","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"Let us use a half circle in phase space as our surface. To get the points in phase space used in approximating our surface, we use the getpoints function.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> phasepoints = getpoints(pinv) do r, θ\n           s, c = sincospi(θ)\n           return r .* (c, s)\n       end;","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"Finally, we may compute the integral invariant using the function compute!. The last two arguments represent the time and any additional parameters. Both are passed to the two-form function ω(z, t, p).","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> p = compute!(pinv, phasepoints, 0, nothing)\n1.570796326794897\n\njulia> (p - π/2) < 5eps()\ntrue","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"We can see that the answer is accurate within five times machine epsilon. If we now evolve each point forward in time, we should see that the invariant is conserved.","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"julia> function free_particle!(points, t)\n           mid = size(points, 2) ÷ 2\n           for pnt in eachrow(points)\n               for j in 1:mid\n                   pnt[j] += pnt[mid + j] .* t\n               end\n           end\n       end\nfree_particle! (generic function with 1 method)\n\njulia> free_particle!(phasepoints, 100);\n\njulia> abs(compute!(pinv, phasepoints, 0, nothing) - π/2) < 50eps()\ntrue","category":"page"},{"location":"second_poincare_invariants/","page":"Guide","title":"Guide","text":"We find that up to some numerical error the invariant is indeed conserved.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"DocTestSetup  = quote\n    using PoincareInvariants\nend","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"PoincareInvariants\nAbstractPoincareInvariant\ncompute!\ngetpoints\ngetpointnum\ngetdim\ngetform","category":"page"},{"location":"reference/#PoincareInvariants","page":"Reference","title":"PoincareInvariants","text":"PoincareInvariants\n\nA Julia library for the computation of Poincaré integral invariants.\n\n\n\n\n\n","category":"module"},{"location":"reference/#PoincareInvariants.AbstractPoincareInvariant","page":"Reference","title":"PoincareInvariants.AbstractPoincareInvariant","text":"AbstractPoincareInvariant{T, D}\n\nrepresents a Poincare integral invariant in a phase space of dimension D using numeric type T for calculations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PoincareInvariants.compute!","page":"Reference","title":"PoincareInvariants.compute!","text":"compute!(pinv::AbstractPoincareInvariant, args...)\n\ncomputes a Poincaré invariant.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getpoints","page":"Reference","title":"PoincareInvariants.getpoints","text":"getpoints(pinv::AbstractPoincareInvariant)\n\nreturns points on which to evaluate the phase space line or surface parameterisation so as to compute! pinv.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getpointnum","page":"Reference","title":"PoincareInvariants.getpointnum","text":"getpointnum(pinv::AbstractPoincareInvariant)\n\nreturns number of points to sample in phase space to compute! pinv.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getdim","page":"Reference","title":"PoincareInvariants.getdim","text":"getdim(pinv::AbstractPoincareInvariant)\n\nreturns dimension of phase space to compute! pinv in.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PoincareInvariants.getform","page":"Reference","title":"PoincareInvariants.getform","text":"getform(pinv::AbstractPoincareInvariant)\n\nget invariant one- or two-form.\n\n\n\n\n\n","category":"function"},{"location":"chebyshev_implementation/#Chebyshev-Implementation","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"","category":"section"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"Here, I describe how the second Poincaré invariant is calculated using the SecondChebyshevPlan. The code for the compute! function in this implementation looks something like:","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"function compute!(plan::ChebyshevPlan, ω, phasepoints, t, p)\n    paduatransform!(plan.phasecoeffs, plan.paduaplan, phasepoints)\n    differentiate!(plan.∂x, plan.∂y, plan.diffplan, plan.phasecoeffs)\n    getintegrand!(plan.intcoeffs, plan.intplan, ω, phasepoints, t, p, plan.∂x, plan.∂y)\n    integrate(plan.intcoeffs, plan.intweights)\nend","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"First, we approximate the surface using Chebyshev polynomials. Coefficients are calculated use the Padua transform, which yields a matrix of coefficients. (See docs on PaduaTransforms)","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"Second, we differentiate the approximated function. Chebyshev polynomials can be differentiated via a linear transformation of the coefficients, yielding coefficients of a new polynomial in the Chebyshev basis. The linear transformation is applied to each column to differentiate with respect to one parameterisation variable and then to each row to differentiate with respect to the other. (See the functions getdiffmat! and differentiate! in the source code)","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"Third, the approximation of the derivatives is evaluated at the Padua points using the inverse Padua transform. The inital forward transform and the two inverse transforms together make up the vast majority of the computational cost.","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"Fourth, at each Padua point the derivatives in both directions (two vectors) and the invariant two-form are contracted via a vector matrix vector product. This is the integrand evaluated at each Padua point. (See getintegrand!)","category":"page"},{"location":"chebyshev_implementation/","page":"Chebyshev Implementation","title":"Chebyshev Implementation","text":"Finally, we put the integrand values through one final Padua transform, obtaining a polynomial approximation of the integrand. This is then integrated in 2D by another vector matrix vector product, where the matrix is the matrix of Chebyshev coefficients and the vector is a vector of definite integrals of each of the Chebyshev polynomials. (See getintweights for the calculation of the definite integrals and integrate to perform the integration.)","category":"page"},{"location":"#PoincareInvariants.jl","page":"Home","title":"PoincareInvariants.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Poincaré integral invariants provide useful diagnostics for analysing the long-time accuracy of numerical integrators for Hamiltonian dynamics and for distinguishing between symplectic and non-symplectic integrators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides means for computing the first and second Poincaré integral invariant vartheta and omega, which are given by the Lagrangian one- and two-form, respectively.","category":"page"},{"location":"#First-Poincaré-Invariant","page":"Home","title":"First Poincaré Invariant","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The one-form vartheta is a relative integral invariant, which means that the integral","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_1 = int_gamma vartheta_i (q)  dq^i","category":"page"},{"location":"","page":"Home","title":"Home","text":"stays constant in time when gamma is a closed loop in the configuration space mathcalM (a compact one-dimensional parametrized submanifold of mathcalM without boundary), that is advected along the solution of the dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figure shows examples of single trajectories of some samples of such a loop, as well as the temporal evolution of the whole loop following the dynamics of the guiding centre system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The loop gamma is parametrized by tau in 01), so that","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_1 (t) = int_0^1 vartheta_i (q_(tau)(t))  dfracd q_(tau)^idtau  dtau ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to compute this integral, we use N equidistant points in 01), so that the derivatives d q_(tau)  dtau can be efficiently computed via discrete Fourier transforms. The integral is approximated with the trapezoidal quadrature rule, which has spectral convergence on periodic domains (Trefethen & Weideman, 2014).","category":"page"},{"location":"#Second-Poincaré-Invariant","page":"Home","title":"Second Poincaré Invariant","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The two-form omega is an absolute integral invariant, which means that the integral","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_2 = int_S omega_ij (q)  dq^i  dq^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"stays constant in time when S is any compact two-dimensional parametrized submanifold of mathcalM, advected along the solution of the dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figure shows how an initially rectangular area in phasespace is advected by the dynamics of the guiding centre system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The area S is parametrized by (sigma tau) in 01^2, so that","category":"page"},{"location":"","page":"Home","title":"Home","text":"I_2 (t) = int_0^1 int_0^1 omega_ij (q_(sigma tau) (t))  dfracdq_(sigma tau)^idsigma  dfracdq_(sigma tau)^jdtau  dsigma  dtau ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we represent the surface in terms of Chebyshev polynomials and thus use Chebyshev points for the discretization of the domain 01^2. The Chebyshev polynomials allow for an extremely accurate approximation of the surface, even if the latter becomes severely deformed. Moreover, they allow for the use of the ApproxFun.jl package for the easy and accurate computation of the derivatives and the integral.","category":"page"}]
}
