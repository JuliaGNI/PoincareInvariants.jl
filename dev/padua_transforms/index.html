<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Padua Transforms · PoincareInvariants.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PoincareInvariants.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../first_poincare_invariants/">First Poincaré Invariants</a></li><li><span class="tocitem">Second Poincaré Invariants</span><ul><li><a class="tocitem" href="../second_poincare_invariants/">Guide</a></li><li><a class="tocitem" href="../chebyshev_implementation/">Chebyshev Implementation</a></li><li class="is-active"><a class="tocitem" href>Padua Transforms</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#The-Algorithm-–-Step-by-Step"><span>The Algorithm – Step by Step</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../canonical_symplectic_structures/">Canonical Symplectic Structures</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Second Poincaré Invariants</a></li><li class="is-active"><a href>Padua Transforms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Padua Transforms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/master/docs/src/padua_transforms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Padua-Transforms"><a class="docs-heading-anchor" href="#Padua-Transforms">Padua Transforms</a><a id="Padua-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Padua-Transforms" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The Padua transform yields coefficients <span>$a_{ij}$</span> used to approximate a bivariate function <span>$f(x, y)$</span> with</p><p class="math-container">\[f(x, y) ≈ \sum_{i, j} a_{ij} \; T_i(y) \; T_j(x)\]</p><p>where <span>$T_n(x) := \cos(n \arccos(x))$</span> is the nth Chebyshev polynomial. For reference, the first few Chebyshev polynomials are</p><p class="math-container">\[\begin{aligned}
T_0(x) &amp;= 1 \\
T_1(x) &amp;= x \\
T_2(x) &amp;= 2x^2 - 1 \\
T_3(x) &amp;= 4x^3 - 3x \\
T_4(x) &amp;= 8x^4 - 8x^2 + 1
\end{aligned}\]</p><p>The inverse transform takes the coefficients <span>$a_{ij}$</span> and returns the function <span>$f(x, y)$</span> evaluated at the so called Padua points.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Start by evaluating a function on the Padua points. Here we approximate the function with a polynomial of total degree 3. The total degree is the degree of the largest polynomial in x plus the degree of the largest polynomial in y.</p><pre><code class="language-julia-repl hljs">julia&gt; vals = getpaduapoints(3) do x, y
           y * (2x^2 - 1) + 5 * x * y + 2.5
       end
10-element Vector{Float64}:
  8.5
  2.5
 -3.5
  3.914213562373095
  1.0857864376269049
 -0.5
  2.5
  5.5
 -0.3284271247461903
  5.32842712474619</code></pre><p>Then create a <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.PaduaTransformPlan"><code>PaduaTransformPlan</code></a> and apply the <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduatransform!"><code>paduatransform!</code></a> to get the Chebyshev coefficeints <span>$a_{ij}$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; plan = PaduaTransformPlan{Float64}(3);

julia&gt; coeffs = paduatransform!(zeros(4, 4), plan, vals)
4×4 Matrix{Float64}:
 2.5  0.0  0.0  0.0
 0.0  5.0  1.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0</code></pre><p>We can go back to values using an <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.InvPaduaTransformPlan"><code>InvPaduaTransformPlan</code></a> and applying <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!"><code>invpaduatransform!</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; invplan = InvPaduaTransformPlan{Float64}(3);

julia&gt; out = invpaduatransform!(Vector{Float64}(undef, getpaduanum(3)), invplan, coeffs)
10-element Vector{Float64}:
  8.5
  2.5
 -3.5
  3.914213562373095
  1.0857864376269049
 -0.5
  2.5
  5.5
 -0.3284271247461903
  5.32842712474619

julia&gt; out ≈ vals
true</code></pre><p>where we used <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduanum"><code>getpaduanum</code></a> to get the number of Padua points and coefficients corresponding to total degree 3.</p><h2 id="The-Algorithm-–-Step-by-Step"><a class="docs-heading-anchor" href="#The-Algorithm-–-Step-by-Step">The Algorithm – Step by Step</a><a id="The-Algorithm-–-Step-by-Step-1"></a><a class="docs-heading-anchor-permalink" href="#The-Algorithm-–-Step-by-Step" title="Permalink"></a></h2><p>To obtain the coefficients <span>$a_{ij}$</span> we need to evaluate the function <span>$f$</span> at some points <span>$(x_l, y_k)$</span> and evaluate</p><p class="math-container">\[a_{ij} = \sum_{k, l} \; f(x_l, y_k) \; T_i(y_k) \; T_j(x_l)\]</p><p>Note, that this is not quite exact since we will apply a weighting factor to the coefficients. If we let <span>$x_l = \cos{\frac{lπ}{n}}$</span> and <span>$y_k = \cos{\frac{kπ}{m}}$</span>, we have</p><p class="math-container">\[a_{ij} = \sum_{k, l} \; f(\cos{\frac{lπ}{n}}, \cos{\frac{kπ}{m}}) \; T_i(\cos{\frac{kπ}{m}}) \; T_j(\cos{\frac{lπ}{n}})\]</p><p>which simplifies to</p><p class="math-container">\[a_{ij} = \sum_{k, l} \; f(\cos{\frac{lπ}{n}}, \cos{\frac{kπ}{m}}) \; \cos{\frac{ikπ}{m}} \; \cos{\frac{jlπ}{n}}\]</p><p>because of the definition of the Chebyshev polynomials as <span>$T_n(x) := \cos(n \arccos(x))$</span>. The expression above looks like a discrete cosine transform, which is what we will use to implement the Padua transform. For further reading on the Padua Transform, please see the following:</p><p>For details on the Padua points as good nodes for polynomial interpolation: <a href="https://doi.org/10.1016/j.amc.2004.07.001">Marco Caliari, Stefano De Marchi, Marco Vianello. Bivariate polynomial interpolation on the square at new nodal sets</a></p><p>and for details on the implementation of the transform via a discrete cosine transform: <a href="https://link.springer.com/content/pdf/10.1007/s11075-010-9373-1.pdf">Marco Caliari, Stefano De Marchi, Alvise Sommariva, Marco Vianello. Padua2DM: fast interpolation and cubature at the Padua points in Matlab/Octave</a></p><h3 id="The-Padua-Points"><a class="docs-heading-anchor" href="#The-Padua-Points">The Padua Points</a><a id="The-Padua-Points-1"></a><a class="docs-heading-anchor-permalink" href="#The-Padua-Points" title="Permalink"></a></h3><p>There are multiple ways to define the set of Padua points. For our purposes we will use</p><p class="math-container">\[\textrm{Pad}_n = \{(\cos{\frac{jπ}{n}}, \cos{\frac{iπ}{n + 1}}) \; | \; 0 ≤ j ≤ n, \; 0 ≤ i ≤ n + 1, \; i - j \; \textrm{even} \}\]</p><p>where <span>$n$</span> is the total degree of the polynomial we can approximate using the Padua points. To generate the Padua points we can use the function <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduapoints"><code>getpaduapoints</code></a> as follows</p><pre><code class="language-julia-repl hljs">julia&gt; getpaduapoints(3)
([1.0, 1.0, 1.0, 0.5, 0.5, -0.4999999999999999, -0.4999999999999999, -0.4999999999999999, -1.0, -1.0], [1.0, 0.0, -1.0, 0.7071067811865476, -0.7071067811865476, 1.0, 0.0, -1.0, 0.7071067811865476, -0.7071067811865476])</code></pre><p>Using do block syntax we can evaluate a function on the Padua points.</p><pre><code class="language-julia-repl hljs">julia&gt; vals = getpaduapoints(3) do x, y
                  y * (2x^2 - 1) + 5 * x * y + 2.5
              end
10-element Vector{Float64}:
  8.5
  2.5
 -3.5
  3.914213562373095
  1.0857864376269049
 -0.5
  2.5
  5.5
 -0.3284271247461903
  5.32842712474619</code></pre><h3 id="The-Padua-Transform"><a class="docs-heading-anchor" href="#The-Padua-Transform">The Padua Transform</a><a id="The-Padua-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#The-Padua-Transform" title="Permalink"></a></h3><p>Having evaluated our function on the Padua points, we can perform the transform. First, we initialise a transform plan.</p><pre><code class="language-julia-repl hljs">julia&gt; plan = PaduaTransformPlan{Float64}(3);</code></pre><p>The transform consists of writing <code>vals</code> into <code>plan.vals</code>, applying a fast fourier transform and weighting the resulting coefficients to obtain the Chebyshev coefficients. We start by writting values into the values matrix using <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tovalsmat!"><code>tovalsmat!</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.tovalsmat!(plan.vals, vals, 3)
5×4 Matrix{Float64}:
  8.5  0.0      -0.5   0.0
  0.0  3.91421   0.0  -0.328427
  2.5  0.0       2.5   0.0
  0.0  1.08579   0.0   5.32843
 -3.5  0.0       5.5   0.0</code></pre><p><code>vals</code> are written into the matrix <code>plan.vals</code> such that the entry <code>plan.vals[i+1, j+1]</code> corresponds to the Padua point <span>$(\cos{\frac{jπ}{n}}, \cos{\frac{iπ}{n + 1}})$</span>. However, since the Padua points are only those points with <span>$i-j$</span> even, all entries corresponding to <span>$i-j$</span> odd are left out. These off grid entries must be filled with 0. Next, we can apply the discrete cosine transform and <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.weight!"><code>weight!</code></a> the coefficients to obtain the Chebyshev coefficients.</p><pre><code class="language-julia-repl hljs">julia&gt; plan.dctplan * plan.vals
5×4 Matrix{Float64}:
 60.0   0.0   0.0   0.0
  0.0  30.0   6.0   0.0
  0.0   0.0   0.0   0.0
  0.0   6.0  30.0   0.0
  0.0   0.0   0.0  60.0

julia&gt; PaduaTransforms.weight!(plan.vals, 3)
5×4 Matrix{Float64}:
 2.5  0.0  0.0  0.0
 0.0  5.0  1.0  0.0
 0.0  0.0  0.0  0.0
 0.0  1.0  5.0  0.0
 0.0  0.0  0.0  2.5</code></pre><p>The weighting factor we apply to the coefficients is</p><p class="math-container">\[w = \frac{1}{n(n+1)} ⋅ \begin{cases}
    \frac{1}{2} &amp; \textrm{if on vertex}   \\
    1           &amp; \textrm{if on edge}     \\
    2           &amp; \textrm{if in interior} \\
\end{cases}\]</p><p>Finally, we write those coefficients corresponding to a total degree of 3 or lower (the upper left triangular) into the output.</p><pre><code class="language-julia-repl hljs">julia&gt; coeffs = zeros(4, 4)
4×4 Matrix{Float64}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; PaduaTransforms.fromcoeffsmat!(coeffs, plan.vals, 3)
4×4 Matrix{Float64}:
 2.5  0.0  0.0  0.0
 0.0  5.0  1.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0</code></pre><h3 id="The-Inverse-Padua-Transform"><a class="docs-heading-anchor" href="#The-Inverse-Padua-Transform">The Inverse Padua Transform</a><a id="The-Inverse-Padua-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#The-Inverse-Padua-Transform" title="Permalink"></a></h3><p>If we have a set of Chebyshev coefficients and want to obtain the values of the corresponding Chebyshev polynomial on the Padua points, we must use the inverse Padua transform. Again, we start with a plan and write our coefficients into <code>plan.coeffs</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; invplan = InvPaduaTransformPlan{Float64}(3);

julia&gt; PaduaTransforms.tocoeffsmat!(invplan.coeffs, coeffs)
5×4 Matrix{Float64}:
 2.5  0.0  0.0  0.0
 0.0  5.0  1.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0</code></pre><p>Next, we weight the coefficients using <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invweight!"><code>invweight!</code></a> and apply a discrete cosine transform.</p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.invweight!(invplan.coeffs)
5×4 Matrix{Float64}:
 2.5  0.0   0.0   0.0
 0.0  1.25  0.25  0.0
 0.0  0.0   0.0   0.0
 0.0  0.0   0.0   0.0
 0.0  0.0   0.0   0.0

julia&gt; invplan.dctplan * invplan.coeffs
5×4 Matrix{Float64}:
  8.5      4.5      -0.5      -1.5
  6.74264  3.91421   0.37868  -0.328427
  2.5      2.5       2.5       2.5
 -1.74264  1.08579   4.62132   5.32843
 -3.5      0.5       5.5       6.5</code></pre><p><a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invweight!"><code>invweight!</code></a> applies the weighting</p><p class="math-container">\[w = \begin{cases}
    1           &amp; \textrm{if on vertex}   \\
    \frac{1}{2} &amp; \textrm{if on edge}     \\
    \frac{1}{4} &amp; \textrm{if in interior} \\
\end{cases}\]</p><p>Finally, we copy over those values corresponding to <span>$i-j$</span> even and we have our values back.</p><pre><code class="language-julia-repl hljs">julia&gt; out = PaduaTransforms.fromvalsmat!(Vector{Float64}(undef, getpaduanum(3)), invplan.coeffs, 3)
10-element Vector{Float64}:
  8.5
  2.5
 -3.5
  3.914213562373095
  1.0857864376269049
 -0.5
  2.5
  5.5
 -0.3284271247461903
  5.32842712474619

julia&gt; vals ≈ out
true</code></pre><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">PaduaTransforms</code></pre><p>an implementation of the Padua transform and its inverse via the fast Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L1-L5">source</a></section></article><h3 id="Padua-Points"><a class="docs-heading-anchor" href="#Padua-Points">Padua Points</a><a id="Padua-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Padua-Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduapoints" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduapoints"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduapoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpaduapoints([f::Function,], [T=Float64,] n)</code></pre><p>evaluates the function <code>f</code> on the Padua points (of type <code>T</code>) for degree <code>n</code>.</p><p>If no function <code>f</code> is provided, <code>getpaduapoints</code> returns a tuple of two vectors containing the x and y components of the paduapoints respectively. If <code>f</code> returns a single value, <code>getpaduapoints</code> returns a <code>Vector{T}</code>. If <code>f</code> returns a tuple or other indexable iterable, <code>getpaduapoints</code> returns a tuple of <code>Vector{T}</code> where the i-th vector represents the i-th entry in <code>f</code> applied to all the Padua points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getpaduapoints(2)
([1.0, 1.0, 0.0, 0.0, -1.0, -1.0], [1.0, -0.4999999999999999, 0.5, -1.0, 1.0, -0.4999999999999999])

julia&gt; getpaduapoints(Float32, 1)
(Float32[1.0, 1.0, -1.0], Float32[1.0, -1.0, 0.0])

julia&gt; getpaduapoints(Float32, 2) do x, y; x*y; end
6-element Vector{Float32}:
  1.0
 -0.50000006
  0.0
 -0.0
 -1.0
  0.50000006

julia&gt; getpaduapoints(2) do x, y; x*y, 5*x*y; end
([1.0, -0.4999999999999999, 0.0, -0.0, -1.0, 0.4999999999999999], [5.0, -2.4999999999999996, 0.0, -0.0, -5.0, 2.4999999999999996])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L144-L175">source</a></section></article><h3 id="Numbers-of-Coefficients-and-Points"><a class="docs-heading-anchor" href="#Numbers-of-Coefficients-and-Points">Numbers of Coefficients and Points</a><a id="Numbers-of-Coefficients-and-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Numbers-of-Coefficients-and-Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduanum" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduanum"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getpaduanum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpaduanum(n)</code></pre><p>calculates number of Padua points needed to approximate a function using Chebyshev polynomials up to total degree <code>n</code>. This number is equal to the number of coefficients. The formula is</p><p class="math-container">\[N = (n + 1) ⋅ (n + 2) ÷ 2\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getpaduanum(13)
105</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L18-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getdegree" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getdegree"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.getdegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdegree(N)</code></pre><p>calculates total degree, given the number of coefficients or Padua points <code>N</code>. Throws an error if <code>N</code> is not a possible number of Padua points. The formula is</p><p class="math-container">\[n = \frac{\sqrt{1 + 8N} - 3}{2}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; getdegree(105)
13

julia&gt; getdegree(104)
ERROR: ArgumentError: number of Padua points or coeffs must be (n + 1) * (n + 2) ÷ 2
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L37-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextpaduanum" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextpaduanum"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextpaduanum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nextpaduanum(N)</code></pre><p>get next valid number of Padua points ≥ <code>N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextpaduanum(104)
105</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextdegree" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextdegree"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.nextdegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nextdegree(N)</code></pre><p>get degree of <code>nextpaduanum(N)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextdegree(104)
13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L63-L74">source</a></section></article><h3 id="Padua-Transform"><a class="docs-heading-anchor" href="#Padua-Transform">Padua Transform</a><a id="Padua-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Padua-Transform" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.PaduaTransformPlan" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.PaduaTransformPlan"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.PaduaTransformPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PaduaTransformPlan{T}(n::Integer)</code></pre><p>create plan to compute coefficients of Chebyshev polynomials in 2D up to total degree <code>n</code> using the Padua transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduatransform!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduatransform!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduatransform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paduatransform!(coeffs, P::PaduaTransformPlan, vals[, lex])</code></pre><p>obtain coefficients of Chebyshev polynomials on 2D via the Padua transform, given values <code>vals</code> evaluated at the Padua points. Coefficients will be written into <code>coeffs</code>, which should either be a matrix, a vector or an iterable of either.</p><p>If an iterable of <code>vals</code> vectors and a corresponding iterable of <code>coeffs</code> matrixes or vectors is given, each <code>vals</code> vector will be transformed seperately in a multidimensional Padua transform.</p><p><code>lex</code> determines the order in which coefficients are written into <code>out</code> if <code>out</code> is a vector. See <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromcoeffsmat!"><code>fromcoeffsmat!</code></a> for details.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>if <code>coeffs</code> is a matrix, make sure that all entries in the lower right diagonal are zero as these will not get overwritten.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; plan = PaduaTransformPlan{Float64}(2);

julia&gt; f(x, y) = 3 + 4x + 5 * x*y, 6 + 7y
f (generic function with 1 method)

julia&gt; vals = getpaduapoints(f, 2)
([12.0, 4.5, 3.0, 3.0, -6.0, 1.4999999999999996], [13.0, 2.500000000000001, 9.5, -1.0, 13.0, 2.500000000000001])

julia&gt; paduatransform!(zeros(3, 3), plan, vals[1])
3×3 Matrix{Float64}:
 3.0  4.0  0.0
 0.0  5.0  0.0
 0.0  0.0  0.0

julia&gt; paduatransform!(zeros(6), plan, vals[2], Val(true))
6-element Vector{Float64}:
 6.0
 0.0
 7.0
 0.0
 0.0
 0.0

julia&gt; paduatransform!((zeros(3, 3), zeros(3, 3)), plan, vals)
([3.0 4.0 0.0; 0.0 5.0 0.0; 0.0 0.0 0.0], [6.0 0.0 0.0; 7.0 0.0 0.0; 0.0 0.0 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L445-L491">source</a></section></article><h3 id="Inverse-Padua-Transform"><a class="docs-heading-anchor" href="#Inverse-Padua-Transform">Inverse Padua Transform</a><a id="Inverse-Padua-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-Padua-Transform" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.InvPaduaTransformPlan" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.InvPaduaTransformPlan"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.InvPaduaTransformPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InvPaduaTransformPlan{T}(n::Integer)</code></pre><p>create plan to compute values on Padua points, given coefficients of Chebyshev polynomials up to total degree <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L526-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invpaduatransform!(vals::AbstractVector, IP::InvPaduaTransformPlan, coeffs::AbstractMatrix)</code></pre><p>evaluates the polynomial defined by the coefficients of Chebyshev polynomials <code>coeffs</code> on the Padua points using the inverse transform plan <code>IP</code> and writes the resulting values into <code>vals</code>.</p><p>If an iterable of <code>vals</code> vectors and a corresponding iterable of <code>coeffs</code> matrixes is given, each <code>coeffs</code> matrix will be transformed seperately.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iplan = InvPaduaTransformPlan{Float64}(2);

julia&gt; coeffs = [3 4 0; 0 5 0; 0 0 0]
3×3 Matrix{Int64}:
 3  4  0
 0  5  0
 0  0  0

julia&gt; invpaduatransform!(zeros(6), iplan, coeffs)
6-element Vector{Float64}:
 12.0
  4.5
  3.0
  3.0
 -6.0
  1.5

julia&gt; getpaduapoints(2) do x, y; 3 + 4x + 5 * x*y; end
6-element Vector{Float64}:
 12.0
  4.5
  3.0
  3.0
 -6.0
  1.4999999999999996</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L646-L684">source</a></section></article><h3 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduapoint" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduapoint"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduapoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paduapoint(T::Type, j::Integer, i::Integer, n::Integer)</code></pre><p>returns the Padua point <span>$z_{ij}$</span>, where</p><p class="math-container">\[z_{ij} = (\cos{\frac{jπ}{n}}, \cos{\frac{iπ}{n+1}})\]</p><p>Note, that only points with <span>$i-j$</span> even are actually Padua points. Check with <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.ispadua"><code>ispadua</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [PaduaTransforms.paduapoint(Float32, x, y, 1) for y in 0:1+1, x in 0:1]
3×2 Matrix{Tuple{Float32, Float32}}:
 (1.0, 1.0)   (-1.0, 1.0)
 (1.0, 0.0)   (-1.0, 0.0)
 (1.0, -1.0)  (-1.0, -1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L93-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.ispadua" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.ispadua"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.ispadua</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ispadua(i, j)</code></pre><p>returns if <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduapoint"><code>paduapoint</code></a> at position <code>(i, j)</code> is a Padua point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pointornothing(i, j, n) = PaduaTransforms.ispadua(i, j) ? PaduaTransforms.paduapoint(Float64, j, i, n) : nothing
pointornothing (generic function with 1 method)

julia&gt; [pointornothing(y, x, 2) for y in 0:3, x in 0:2]
4×3 Matrix{Union{Nothing, Tuple{Float64, Float64}}}:
 (1.0, 1.0)   nothing      (-1.0, 1.0)
 nothing      (0.0, 0.5)   nothing
 (1.0, -0.5)  nothing      (-1.0, -0.5)
 nothing      (0.0, -1.0)  nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L121-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tovalsmat!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tovalsmat!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tovalsmat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tovalsmat!(mat::Matrix, from::AbstractVector, degree::Integer)</code></pre><p>write values of function evaluated at Padua points from <code>from</code> to matrix <code>mat</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.tovalsmat!(ones(3 + 2, 3 + 1), 1:getpaduanum(3), 3)
5×4 Matrix{Float64}:
 1.0  0.0  6.0   0.0
 0.0  4.0  0.0   9.0
 2.0  0.0  7.0   0.0
 0.0  5.0  0.0  10.0
 3.0  0.0  8.0   0.0

julia&gt; PaduaTransforms.tovalsmat!(ones(2 + 2, 2 + 1), 1:getpaduanum(2), 2)
4×3 Matrix{Float64}:
 1.0  0.0  5.0
 0.0  3.0  0.0
 2.0  0.0  6.0
 0.0  4.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L260-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.weight!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.weight!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.weight!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight!(mat::AbstractMatrix, degree::Integer)</code></pre><p>weight fourier coefficients to obtain Chebyshev coefficients as part of a <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.paduatransform!"><code>paduatransform!</code></a>. The weighting factor applied to the coefficients is</p><p class="math-container">\[w = \frac{1}{n(n+1)} ⋅ \begin{cases}
    \frac{1}{2} &amp; \textrm{if on vertex}   \\
    1           &amp; \textrm{if on edge}    \\
    2           &amp; \textrm{if in interior} \\
\end{cases}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; weight!(ones(4+2, 4+1), 4)
6×5 Matrix{Float64}:
 0.025  0.05  0.05  0.05  0.025
 0.05   0.1   0.1   0.1   0.05
 0.05   0.1   0.1   0.1   0.05
 0.05   0.1   0.1   0.1   0.05
 0.05   0.1   0.1   0.1   0.05
 0.025  0.05  0.05  0.05  0.025</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L224-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromcoeffsmat!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromcoeffsmat!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromcoeffsmat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fromcoeffsmat!(to::AbstractVector, mat::Matrix, degree::Integer, ::Val{lex})</code></pre><p>write Chebyshev coefficients from <code>mat</code> into vector <code>to</code>. <code>lex::Bool</code> determines whether coefficients should be written in lexigraphical order or not. The lower right triangle does not get written into <code>to</code>. These would represent greater polynomial degrees than <code>degree</code>.</p><p>If <code>lex</code> is <code>Val(true)</code> the coefficients correspond to the following basis polynomials</p><p class="math-container">\[T_0(x) T_0(y), T_1(x) T_0(y), T_0(x) T_1(y), T_2(x) T_0(y), T_1(x) T_1(y), T_0(x) T_2(y), ...\]</p><p>else if <code>lex</code> is <code>Val(false)</code> they correspond to</p><p class="math-container">\[T_0(x) T_0(y), T_0(x) T_1(y), T_1(x) T_0(y), T_0(x) T_2(y), T_1(x) T_1(y), T_2(x) T_0(y), ...\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [(x, y) for y in 0:2+1, x in 0:2]
4×3 Matrix{Tuple{Int64, Int64}}:
 (0, 0)  (1, 0)  (2, 0)
 (0, 1)  (1, 1)  (2, 1)
 (0, 2)  (1, 2)  (2, 2)
 (0, 3)  (1, 3)  (2, 3)

julia&gt; to1 = similar(mat, getpaduanum(2)); to2 = similar(mat, getpaduanum(2));

julia&gt; fromcoeffsmat!(to1, mat, 2, Val(true))
6-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (1, 0)
 (0, 1)
 (2, 0)
 (1, 1)
 (0, 2)

julia&gt; fromcoeffsmat!(to2, mat, 2, Val(false))
6-element Vector{Tuple{Int64, Int64}}:
 (0, 0)
 (0, 1)
 (1, 0)
 (0, 2)
 (1, 1)
 (2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L325-L373">source</a></section><section><div><pre><code class="nohighlight hljs">fromcoeffsmat!(to::AbstractMatrix, mat::Matrix, degree::Integer)</code></pre><p>copy Chebyshev coefficients from <code>mat</code> to <code>to</code> without copying coefficients coresponding to total degree greater than <code>degree</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.fromcoeffsmat!(zeros(4, 4), reshape(1:20, 5, 4), 3)
4×4 Matrix{Float64}:
 1.0  6.0  11.0  16.0
 2.0  7.0  12.0   0.0
 3.0  8.0   0.0   0.0
 4.0  0.0   0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L414-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tocoeffsmat!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tocoeffsmat!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.tocoeffsmat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tocoeffsmat!(mat::AbstractMatrix, coeffs::AbstractMatrix)</code></pre><p>writes coefficients in <code>coeffs</code> into matrix <code>mat</code> for the <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!"><code>invpaduatransform!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.tocoeffsmat!(zeros(5, 4), reshape(1:16, 4, 4))
5×4 Matrix{Float64}:
 1.0  5.0   9.0  13.0
 2.0  6.0  10.0  14.0
 3.0  7.0  11.0  15.0
 4.0  8.0  12.0  16.0
 0.0  0.0   0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L539-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invweight!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invweight!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invweight!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invweight!(coeffs::AbstractMatrix)</code></pre><p>weight Chebyshev coefficients before the Fourier transform for the <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!"><code>invpaduatransform!</code></a>. using the weighting</p><p class="math-container">\[w = \begin{cases}
    1            &amp; \textrm{if on vertex}   \\
    \frac{1}{2} &amp; \textrm{if on edge}     \\
    \frac{1}{4} &amp; \textrm{if in interior} \\
\end{cases}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PaduaTransforms.invweight!(ones(5, 5))
5×5 Matrix{Float64}:
 1.0  0.5   0.5   0.5   1.0
 0.5  0.25  0.25  0.25  0.5
 0.5  0.25  0.25  0.25  0.5
 0.5  0.25  0.25  0.25  0.5
 1.0  0.5   0.5   0.5   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L562-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromvalsmat!" href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromvalsmat!"><code>PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.fromvalsmat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fromvalsmat!(to::AbstractVector, mat::AbstractMatrix, n::Integer)</code></pre><p>write values from <code>mat</code> into the vector <code>to</code> after an <a href="#PoincareInvariants.SecondPoincareInvariants.Chebyshev.PaduaTransforms.invpaduatransform!"><code>invpaduatransform!</code></a> of total degree <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/PoincareInvariants.jl/blob/31cc6cbfe993e716f001c27643525a3fad573bed/src/SecondPoincareInvariants/PaduaTransforms.jl#L594-L599">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../chebyshev_implementation/">« Chebyshev Implementation</a><a class="docs-footer-nextpage" href="../canonical_symplectic_structures/">Canonical Symplectic Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Tuesday 22 March 2022 17:53">Tuesday 22 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
